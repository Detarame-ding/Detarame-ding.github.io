[{"content":"Bulk-RNA测序上游分析——从reads到counts 转录组基础知识 以下记载了转录组最基础的一些知识，这些概念在RNA测序分析中是至关重要的：\n1、基因组Genome：指某一特定物种细胞内或病毒颗粒内的一整套遗传物质（DNA或RNA）。对于人类而言，人类细胞是二倍体，有2套染色体，其中任何一套染色体的DNA序列即为一个基因组，比如人类基因组就是1-22号染色体+X+Y。在广义上，线粒体DNA也可以算作基因组的一部分。\n2、转录组Transcriptome：广义上指在某种条件下在一个细胞或一群细胞中所转录出的RNA总和，包括mRNA、rRNA、tRNA和其他非编码RNA等。狭义的转录组特指转录出的mRNA。转录组和基因组的差别在于，基因组在给定的细胞株上一般不变，而转录组可能会有很大变化，它反映了在给定条件下细胞内活跃表达的基因，故也成为“基因表达谱”。\n3、转录Transcription：即在RNA聚合酶的作用下，遗传信息由DNA复制到RNA的过程。其分为三个过程：启动、延伸和终止。由RNA聚合酶和转录因子共同结合到模板DNA的启动子序列上开启转录过程，接着按互补配对原则进行延伸，最后通过依赖ρ因子的终止或非依赖ρ因子的终止来终止转录。转录出的初级转录RNA包括以下区域：5’UTR（5’非翻译区）、3’UTR（3’非翻译区）、Intron（内含子）、Exon（外显子）。\n4、转录后修饰Post-transcriptional modification：是指在真核细胞中，将初级转录RNA转化为成熟RNA的过程。包括3个过程：5’端加帽、3’端加尾以及RNA剪切。\n5、可变剪接Alternative splicing：又称可变剪接，即一条未经剪接的RNA，含有的多种外显子被剪成不同的组合，因而翻译成不同的蛋白质。剪切出的不同mRNA即为mRNA异构体（isomer）。\n6、转录本Transcript：即一条mRNA。一条基因可能有不同的转录本，其中一个原因就是可变剪切。\n硬件和软件的准备 1、个人计算机的准备:\n操作系统：Ubuntu 24.04 LTS\nRAM：16G；硬盘：500G\n2、软件的准备。\n不具体介绍某个软件的下载方法\n一般的软件安装命令方法如下：\n1 sudo apt install Name_of_Software 或者直接在Github等网站上下载\n3、将软件所在位置添加入环境变量，或将PYTHON脚本添加到PYTHON环境变量:\n1 2 3 echo \u0026#39;export PATH=path/to/your/software:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PYTHONPATH=path/to/your/python_script:$PYTHONPATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc #重新加载环境变量 FASTQ和FASTA文件概述 RNA测序分析的第一步是从测序的原始数据开始的。测序公司返回的原始数据文件是FASTQ格式，里面的每一条记录就是一个read读段。还有一种类似的数据格式叫做FASTA，一般用来记录已经组装好的、参考基因组的序列。\n使用以下命令下载本例所需的文件：\n1 2 3 4 5 wget ftp://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqGm12892R2x75Il200FastqRd1Rep2V2.fastq.gz wget ftp://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqGm12892R2x75Il200FastqRd2Rep2V2.fastq.gz wget ftp://ftp.ensembl.org/pub/release-74/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.74.dna.toplevel.fa.gz 其中，前两个文件为来自淋巴母细胞系的双端测序文件，数据在加利福尼亚理工学院产生，来自早期Illumina平台。下载完毕后解压并重命名为Read1.fastq，Read2.fastq。第三个文件是从ENSRMBL网站上下载的人类参考基因组，解压后大小约为30Gb。下载完解压并重命名为Homo_sapiens.GRCh37.74.dna.toplevel.fa。\n分别打开Read1.fastq和Read2.fastq两个文件，可以发现其前四行分别为：\n1 2 3 4 @HWUSI-EAS1665_28:5:1:1038:939/1 NNNNGGGGTAGGAGNNNNNNNNNGGAGCCAAGGGGGCGTGGCTACGATCTGTGGGACTATGACTGAAATGCTGTA + BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB 以及\n1 2 3 4 @HWUSI-EAS1665_28:5:1:1038:939/2 GCACAGGCGGGGGTCACTCTTTTTTGGGTCCTCCGAAATTCGCGGGGAGGATTCAACATCACGAAGCTTGCCGCA + BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB Read1.fastq和Read2.fastq中每一条记录都是一一对应的，代表同一条mRNA的两端的序列。每一条fastq记录都由4行组成：\n第一行记录了测序时的相关信息，其中@HWUSI-EAS1665_28是测序机器名称，5代表测序槽lane的序号，1代表测序小室tile的编号，1038和939分别是tile内的XY坐标，/1代表是正向测序序列，/2代表是逆向测序序列。\n第二行是测得的mRNA序列，本里中所有的记录都是75bp的，用ATCG代表四种碱基，N代表不确定的模糊碱基。\n第三行是一个加号（+）作为分隔符。\n第四行是碱基的质量Q，Q为-10*lg(P)再四舍五入到整数，其中P是碱基错误的概率，再将Q加上33转化为ASCII码（phred33编码）【如果是低于1.8版本的Illumina软件产生的FASTQ文件则是Q+64转化为ASCII码（phred64编码），本例就是phred64编码的】。\n接着，打开Homo_sapiens.GRCh37.74.dna.toplevel.fa，其前两行为：\n1 2 \u0026gt;1 dna:chromosome chromosome:GRCh37:1:1:249250621:1 REF NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN… 该文件的每条记录都由2行组成：\n第一行记录了基因组的相关信息，本例中\u0026gt;1代表是1号染色体，dna:chromosome代表记录的是染色体DNA，chromosome:GRCh37代表是人类基因组版本GRCh37的数据，1代表染色体编号为1，1:249250621代表起始位置从1到249250621，1代表正链，REF说明这是个参考序列。\n第二行即为基因序列。\n质量控制与预处理 1、用fastqc对原始文件生成一个质量报告。\n1 2 fastqc Read1.fastq.gz fastqc Read2.fastq.gz 2、使用Trimmomatic【Trimmomatic版本0.39】过滤掉平均质量低于20（AVGQUAL:20）的read，采用双端测序模式（PE）。\n1 2 cd RnaSeq_Fastq_data #注：下载的所有数据都是放在~/RnaSeq_Fastq_data文件夹下的，下不赘述 java -jar ~/software/Trimmomatic-0.39/trimmomatic-0.39.jar PE -phred64 Read1.fastq.gz Read2.fastq.gz paired1.fq.gz unpaired1.fq.gz paired2.fq.gz unpaired2.fq.gz AVGQUAL:20 其中生成的upaired1/2.fq.gz文件存储了经过过滤幸存、但失去其配对的read。\n3、使用Trimmomatic修剪，当碱基质量低于20(TRAILING:20)时从3’端修剪碱基，并且去除修剪后长度低于50bp(MINLEN:50)的read。该命令作用于双端read。其他修剪方法暂略。\n1 2 cd RnaSeq_Fastq_data java -jar ~/software/Trimmomatic-0.39/trimmomatic-0.39.jar PE -phred64 Read1.fastq.gz Read2.fastq.gz paired1.fq.gz unpaired1.fq.gz paired2.fq.gz unpaired2.fq.gz TRAILING:20 MINLEN:50 4、接头的去除。案例中原始数据已经进行接头的去除，这里暂略接头的去除方法。\n5、使用prinseq-lite【prinseq-lite版本0.20.4】进行筛选。去除长度小于50的read（-min_len 50），去除平均质量低于20的read（-min_qual_mean 20）【这一工作在已经在1和2中完成，可以省略】；去除低复杂度的read，即熵\u0026lt;70的read（lc_method entrophy lc_threshold 70）；去除模糊碱基N\u0026gt;2的read（ns_max_n 2）。经过滤过后保留配对的文件存储在nfiltered_1/2.fastq中，经过滤过幸存、但失去其配对的read保存在nfiltered_1/2_single-tons.fastq中。这一步骤可能要计算数个小时。\n1 prinseq-lite -fastq Read1.fastq -fastq2 Read2.fastq -min_len 50 -min_qual_mean 20 lc_method entrophy lc_threshold 70 ns_max_n 2 -out_good nfiltered -log -verbose 6、重复read的删除。在RNA-seq中，重复往往是对高度表达的转录本进行测序的自然结果（高表达导致测序重复数多），不建议删除重复。如有必要可以用prinseq-lite来处理，删除出现100次以上（-derep_min 101）的准确重复段（-derep 1）。\n1 prinseq-lite -fastq Read1.fastq -fastq2 Read2.fastq -derep 1 -derep_min 101 -log -verbose -out_good dupfiltered -out_bad null -no_qual_header 将read比对到参考基因组 1、如前所述，在Ensembl上下载人类参考基因组：在http://ftp.ensembl.org/pub/release-74/fasta/homo_sapiens/dna上下载Homo_sapiens.GRCh37.74.dna.toplevel.fa.gz文件并解压，解压后的文件大小约为33Gb。\n1 wget ftp://ftp.ensembl.org/pub/release-74/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.74.dna.toplevel.fa.gz 2、用bowtie2【bowtie2版本2.5.4】生成索引。\n1 bowtie2-build ~/RnaSeq_Fastq_data/Homo_sapiens.GRCh37.74.dna.toplevel.fa/lustre/scratch110/ensembl/amonida/rel74/fasta_dumping_e74/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.74.dna.chromosome.1.fa GRCh37.74 该操作会创建6个bt2l文件，均以CRCh37.74作为索引基本名。该操作会花费数个小时。生成的6个文件是GRCh37.74.1.bt2l；GRCh37.74.2.bt2l；GRCh37.74.3.bt2l；GRCh37.74.4.bt2l；GRCh37.74.rev.1.bt2l；GRCh37.74.rev.2.bt2l。他们的基本名是CRCh37.74。\n3、将read比对到基因组。这里参考的索引基本名是CRCh37.7（-x CRCh47.7），输入文件（-U Read1.fastq.gz）是fastq格式（-q），它使用phred+64编码（\u0026ndash;phred64）。将结果（-S）输出到Read1aligned.sam的文件，这里面不包括未比对的read（\u0026ndash;no-unal）。有8个处理器同时使用以加快对比速度（-p 8）。该操作会花费数个小时。\n如果是单端测序：\n1 bowtie2 -q --phred64 -p 8 --no-unal -x GRCh37.74 -U Read1.fastq.gz -S Read1aligned.sam 如果是双端测序：\n1 bowtie2 -q --phred64 -p 8 --no-unal -x GRCh37.74 -1 Read1.fastq.gz -2 Read2.fastq.gz -S Readaligned.sam #Bowtie2在进行比对时不需要原始的fasta文件，只需要用生成的6个索引文件即可完成比对。比对结束后Bowtie2按照SAM格式报告比对结果，本例中文件名为Readaligned.sam。\n4、使用samtools【samtools版本1.19.2】对SAM文件进一步处理。\n将SAM格式转化为BAM格式以节省空间，并且方便后续的操作。本例中指定输入是SAM文件（-S），输出是BAM文件（-b），输出文件名是alignments.bam（-o alignments.bam）。\n1 samtools view -bS -o alignments.bam Readaligned.sam 在BAM中按染色体坐标进行排序，或者使用名称排序。\n1 samtools sort -o alignments.sorted.bam alignments.bam 给BAM文件编制索引。\n1 samtools index alignments.sorted.bam 这将会生成一个BAI索引文件alignments.sorted.bam.bai\n指定一个染色体或染色体区域，制作对比的子集。本例提取18号染色体的比对制作比对的子集。\n1 samtools view -b -o alignments.sorted.18.bam alignments.sorted.bam 18 基于作图质量过滤比对，本例中保留作图质量高于30的比对。\n1 samtools view -b -q 30 -o alignments_MQmin30.bam alignments.bam 查看统计项目，如多少个read正确配对，或多少个read与其配对read作图到不同染色体等。\n1 samtools flagstat alignment.bam BAM文件索引添加“chr”，如将“1”变成“ch1”（如果需要）：\n1 samtools view -H H1Rep1.18.bam | sed -e \u0026#39;s/SN:\\([0-9XY]\\)/SN:chr**\\1**/\u0026#39; -e \u0026#39;s/SN:MT/SN:chrM/\u0026#39; | samtools reheader - H1Rep1.18.bam \u0026gt; H1Rep1.18.chradded.bam 4、可视化比对的read。可以使用Intergrative Genomics Viewer（IGV）【IGV版本2.4.10】软件对BAM文件进行可视化。可视化过程需要两个文件，即alignments.sorted.bam，以及它的索引文件alignments.sorted.bam.bai。本例中java版本需要切换到java8才能运行IGV\n讨论 讨论1：为什么要制作参考基因组索引？ 将一条read（本例中为75bp）匹配到数以亿计bp的人类基因组并非一件容易的事，而匹配一个样本全部数十万条记录可能会花上数百年的时间。对参考基因组进行预处理，就如同给字典加上目录一样，在查询的时候只需要从目录定位大致位置，再在小范围内查找即可（而不是遍历整个字典）。为参考基因组制作索引可以大大减小比对的时间复杂度，从而优化查找时间。Bowtie2采用的是FM-index压缩技术，该技术基于Burrows-Wheeler Transform（BWT）和Suffix Array（后缀数组）算法，能够在占用较小内存的同时实现快速的子字符串匹配。此外，制作的索引包含了原始fasta文件的所有信息，故bowtie2在进行匹配时只需要用到索引即可，不需要原始fasta文件。在本例中：\nGRCh37.74.1.bt2l、GRCh37.74.2.bt2l包含了FM-index的信息；\nGRCh37.74.3.bt2l、GRCh37.74.4.bt2l包含了额外的索引结构辅助快速定位；\nGRCh37.74.rev.1.bt2l、GRCh37.74.rev.2.bt2l包含了反向互补序列的FM-index信息。\n此外，这些都是二进制文件，无法直接读取。\n讨论2：SAM文件格式 SAM格式储存了bowtie2将read与参考基因组进行比对后的结果。SAM文件内容如下：\n1 2 3 4 5 6 7 8 @HDVN:1.5SO:unsortedGO:query @SQSN:1LN:249250621 … @SQSN:GL000207.1LN:4262 @PGID:bowtie2PN:bowtie2VN:2.5.4CL:\u0026#34;~/software/bowtie2-2.5.4/bowtie2-align-l --wrapper basic-0 -q --phred64 -p 8 -x GRCh37.74 --passthrough -1 Read1.fastq.gz -2 Read2.fastq.gz\u0026#34; HWUSI-EAS1665_28:5:1:1242:9501531762289734275M=762289730TACAGCTACAAGACCTTTCTTGAAAATCTTATTTAATTCTGAGCCCATATTTCACTTACCTTATTTAAAATAAAT92B ??B=:B?;;B-69\u0026gt;G=GFE=F@\u0026lt;4@@F@B55B4B,\u0026lt;=B4==\u0026lt;=3@88@B84\u0026lt;BB-:47B@?=32068=,--4AS:i:-3XN:i:0XM:i:1XO:i:0XG:i:0NM:i:1MD:Z:13A61YT:Z:UP … 其中：\n@HD行为文件头信息，包括版本（VN）、排序方式（SO）和排序方式（GO）\n@SQ行为参考序列信息，包括染色体名称（SN）和长度（LN）\n@PG行为程序信息，包括程序ID（ID）、程序名（PN）、版本号(VN)和指令（CL）\n接下来每行都记录了一条比对信息，由11个必须字段和若干可选字段组成，中间用Tab分隔：\n字段编号 字段名称 说明 1 QNAME 序列名称，本例为HWUSI-EAS1665_28:5:1:1242:950 2 FLAG 比对标志位，用于描述比对的特征和属性，这里153转化为2进制为10011001，代表8个参数 3 RNAME 比对到的参考序列名称，这里1代表比对到1号染色体 4 POS 对比的起始位置，这里之1号染色体的76228973位 5 MAPQ 比对的可信度 6 CIGAR CIGAR字符串，这里75M指75个碱基完全匹配。不同字母所代表的含义不做展开 7 RNEXT 指当前read的配对read比对到的参考序列名称。“=”代表二者对比到了同一个参考序列 8 PNEXT 下一个比对的起始位置 9 TLEN 模板长度，表示该read在参考序列上的覆盖长度。这里0代表数据不可用 10 SEQ read序列 11 QUAL read质量，phred64编码 +1 AS:i 比对得分 +2 XN:i 模糊匹配数，即匹配到多个位置的数量 +3 XM:i 错配数 +4 XO:i 比对过程中发生插入/删除（indel）事件的数量 +5 XG:i 比对中发生插入或删除碱基的总数 +6 NM:i 编辑距离 +7 MD:Z read和参考序列之间的错配位置与类型 +8 YT:Z 比对类型 定量和基于注释的质量控制 1、在UCSC Table Browser上获得人类基因组注释文件：在assembly菜单选择Feb. 2009 (GRCh37/hg19)；Group菜单选择Genes and gene predicitions；Track菜单选择Ensembl gene；region选择genome；output format选择BED – browser extensible data；output file写hg19_Ensembl_chr.bed（因为Ensembl数据集中染色体前缀包括“chr”）。\n2、准备数据集\n在ensembl上下载18号染色体的fasta文件。\n1 wget -c https://ftp.ensembl.org/pub/release-74/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.74.dna.chromosome.18.fa.gz 使用wget命令下载wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep1V2.bam文件，它来自人类胚胎干细胞系，数据在加利福尼亚理工学院产生，来自早期Illumina平台。\n1 wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep1V2.bam 下载对应的注释文件。\n1 wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep1V2.bam.bai 为方便起见将文件分别重命名为H1Rep1.bam和H1Rep1.bam.bai\n从H1Rep1.bam中提取比对到18号染色体的那一部分。\n1 samtools view -b -o H1Rep1.18.bam H1Rep1.bam chr18 将H1Rep1.18.bam排序后制作索引\n1 2 samtools sort -o H1Rep1.18.sorted.bam H1Rep1.18.bam samtools index H1Rep1.18.sorted.bam 3、使用seq命令删除hg19_Ensembl_chr.bed文件中染色体名称的chr前缀（如有必要）。\n1 sed \u0026#39;s/^chr//\u0026#39; hg19_Ensembl_chr.bed \u0026gt;hg19_Ensembl.bed 4、使用RSeQC中的read_distribution.py计算read对不同基因组特征类型的分布。\n1 python3 ~/software/RSeQC-5.0.1/scripts/read_distribution.py -r hg19_Ensembl.bed -i H1Rep1.18.sorted.bam 结果将以表格形式报告read和tag的总数以及所属类型。\n5、使用RSeQC中的geneBody_coverage.py可以生成一个覆盖图来检查转录本的覆盖是否均匀，即是否存在3’端或5’端偏差。\n1 python3 ~/software/RSeQC-5.0.1/scripts/geneBody_coverage.py -r hg19_Ensembl_chr.bed -i H1Rep1.18.bam -o file 运行该程序需要R在$PATH上。\n6、使用RPKM_saturation.py对read的子集重新取样，对每个子集按RPKM单位计算丰度，并检查他们是否稳定。\n1 python3 ~/software/RSeQC-5.0.1/scripts/RPKM_saturation.py -r hg19_Ensembl_chr.bed -i H1Rep1.18.bam -o file 7、使用junction_annotation.py将剪接点划分为“新的”、“部分新”的和“已知的”，分别代表0个、1个、2个剪接位点在参考基因模型中。结果以饼图显示。\n1 python3 ~/software/RseQC-5.0.1/scripts/junction_annotation.py -r hg19_Ensembl_chr.bed -i H1Rep1.18.bam -o file3 8、使用junction_saturation.py检查剪接点的测序饱和状态。软件将检测到的剪接点标记为新的、部分新的和已知的，并通过重新抽样分析其饱和状态。\n1 python3 ~/software/RSeQC-5.0.1/scripts/junction_saturation.py -r hg19_Ensembl_chr.bed -i H1Rep1.18.bam -o file4 9、使用HTSeq-count输出每个基因的计数。HTSeq-count需要SAM/BAM格式的比对文件，以及一个GTF格式的基因组注释文件。Htseq-count期望双端数据按读段名称进行排序，同时BAM文件和注释文件应当有相同的基因名称，本例中需要将GTF文件中基因名称1、2\u0026hellip;转化为chr1、chr2\u0026hellip;\n1 2 3 4 5 wget ftp://ftp.ensembl.org/pub/release-74/gtf/homo_sapiens/Homo_sapiens.GRCh37.74.gtf.gz gunzip Homo_sapiens.GRCh37.74.gtf.gz samtools sort -o H1Rep1.18.namesorted.bam H1Rep1.18.bam sed \u0026#39;s/^\\([0-9XYM]\\)/chr**\\1**/\u0026#39; Homo_sapiens.GRCh37.74.gtf \u0026gt; Homo_sapiens.GRCh37.74.chr.gtf python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no H1Rep1.18.namesorted.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt;counts.txt 10、为了方便对差异进行统计检验，最好删除counts.txt的后5行。\n1 head -n -5 counts.txt \u0026gt; genecounts.txt 至此，我们已经由原始的reads得到了每个基因的counts。下一步，我们将从counts往后进行分析。\n讨论 讨论1：如何度量RNA-Seq数据的质量？ RNA-Seq读段基质量问题，如低置信度碱基问题，已经可以在原始读段水平上检测出，并且用phred64编码的形式报告在fastq文件中。当读段被作图到一个参考基因组，并且它们的位置与注释相匹配时，则可以进一步度量读段的质量，包括：\n测序深度的饱和性：检查测序深度是否接近饱和。\n不同基因组特征之间的读段分布：比如读段在外显子、内含子以及基因间区的分布情况；读段在5’UTR和3’UTR之间的分布情况；读段在蛋白质编码基因、假基因、rRNA、miRNA之间的分布情况等等。\n沿转录本的覆盖均匀性：不同的实验方法可能引入不同的位置偏差，例如一个polyA尾捕获步骤可能导致读段主要来自转录本的3’端。\n讨论2：如何度量基因表达丰度？ $$ \\text{RPKM} = \\frac{\\text{numReads}}{\\left(\\frac{\\text{geneExonLength}}{1000}\\right) \\times \\left(\\frac{\\text{totalNumReads}}{1000000}\\right)} $$ 即，认为一条基因的read数与基因长度和总read数成正比，故将其作为分母除来归一化。这样可以在同一样本中比较不同基因的表达差异。\n$$ \\text{FPKM} = \\frac{\\text{numFragments}}{\\left(\\frac{\\text{geneExonLength}}{1000}\\right) \\times \\left(\\frac{\\text{totalNumFragments}}{1000000}\\right)} $$$$ TPM_i = \\frac{\\frac{N_i}{L_i} \\times 10^6}{\\sum_{k=1}^{n} \\frac{N_k}{L_k}} = \\frac{RPKM_i}{\\sum_{k=1}^{n} RPKM_k} \\times 10^6 $$ 其中Ni指匹配到第i个转录本的read数，Li是第i个转录本的长度。TPM相当于是将RPKM或FPKM归一化，使得在不同样本中可以比较相同基因的表达差异。\n讨论3：操作中输出的counts.txt的数据结构。 该文件的最后几行如下所示：\n1 2 3 4 5 6 7 8 ENSG00000273491\t0 ENSG00000273492\t0 ENSG00000273493\t0 __no_feature\t77237 __ambiguous\t52848 __too_low_aQual\t0 __not_aligned\t0 __alignment_not_unique\t93417 最后5行分别代表没有进行计数的原因和对应的读段数目：比对与任何基因均不重叠、其比对与多个基因重叠、对比质量低于阈值、完全没有比对以及比对到基因组中的多个位置。\nBulk-RNA测序下游分析——从counts开始 数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #下载3个来自GM12892细胞系的BAM与BAI文件，以及4个来自H1hesc细胞系的BAM文件： wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep1V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep2V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep3V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep1V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep2V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep3V2.bam wget -c http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeCaltechRnaSeq/wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep4V2.bam #再分别重命名为GM1/2/3、H1/2/3/4 .bam mv wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep1V2.bam GM1.bam mv wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep2V2.bam GM2.bam mv wgEncodeCaltechRnaSeqGm12892R2x75Il200AlignsRep3V2.bam GM3.bam mv wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep1V2.bam H1.bam mv wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep2V2.bam H2.bam mv wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep3V2.bam H3.bam mv wgEncodeCaltechRnaSeqH1hescR2x75Il200AlignsRep4V2.bam H4.bam #下载人类基因组的注释文件，并将染色体名称加上“chr”。 wget ftp://ftp.ensembl.org/pub/release-74/gtf/homo_sapiens/Homo_sapiens.GRCh37.74.gtf.gz sed \u0026#39;s/^\\([0-9XYM]\\)/chr\\1/\u0026#39; Homo_sapiens.GRCh37.74.gtf Homo_sapiens.GRCh37.74.chr.gtf #将分别提取18号染色体的子集。 samtools sort -o GM1.sorted.bam GM1.bam samtools index GM1.sorted.bam samtools view -b -o GM1.sorted.18.bam GM1.sorted.bam chr18 samtools sort -o GM2.sorted.bam GM2.bam samtools index GM2.sorted.bam samtools view -b -o GM2.sorted.18.bam GM2.sorted.bam chr18 samtools sort -o GM3.sorted.bam GM3.bam samtools index GM3.sorted.bam samtools view -b -o GM3.sorted.18.bam GM3.sorted.bam chr18 samtools sort -o H1.sorted.bam H1.bam samtools index H1.sorted.bam samtools view -b -o H1.sorted.18.bam H1.sorted.bam chr18 samtools sort -o H2.sorted.bam H2.bam samtools index H2.sorted.bam samtools view -b -o H2.sorted.18.bam H2.sorted.bam chr18 samtools sort -o H3.sorted.bam H3.bam samtools index H3.sorted.bam samtools view -b -o H3.sorted.18.bam H3.sorted.bam chr18 samtools sort -o H4.sorted.bam H4.bam samtools index H4.sorted.bam samtools view -b -o H4.sorted.18.bam H4.sorted.bam chr18 #转化为counts python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no GM1.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; GM1.txt python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no GM2.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; GM2.txt python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no GM3.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; GM3.txt ython3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no H1.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; H1.txt python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no H2.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; H2.txt python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no H3.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; H3.txt python3 ~/software/htseq-main/scripts/htseq-count -f bam --stranded no H4.sorted.18.bam Homo_sapiens.GRCh37.74.chr.gtf \u0026gt; H4.txt #去除每个txt的后5行以便后续进行分析。 head -n -5 GM1.txt \u0026gt; GM1.count.txt head -n -5 GM2.txt \u0026gt; GM2.count.txt head -n -5 GM3.txt \u0026gt; GM3.count.txt head -n -5 H1.txt \u0026gt; H1.count.txt head -n -5 H2.txt \u0026gt; H2.count.txt head -n -5 H3.txt \u0026gt; H3.count.txt head -n -5 H4.txt \u0026gt; H4.count.txt 使用R语言进行分析 1、将7个样本的counts合并到一个表格，然后保存在本地。在本例中，7个txt文件在工作目录下的data文件夹里。\n1 2 3 4 5 6 7 8 9 10 samples \u0026lt;- c(paste0(\u0026#39;GM\u0026#39;,1:3),paste0(\u0026#39;H\u0026#39;,1:4)) first.sample \u0026lt;- read.delim(paste0(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\Rscripts\\\\data\\\\\u0026#34;, samples[1],\u0026#34;.count.txt\u0026#34;),header = F, row.names = 1) count.table \u0026lt;- data.frame(first.sample) for(s in samples[2:length(samples)]){ fname \u0026lt;- paste0(\u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\Rscripts\\\\data\\\\\u0026#34;, s, \u0026#34;.count.txt\u0026#34;) column \u0026lt;- read.delim(fname, header = F, row.names = 1) count.table \u0026lt;- cbind(count.table,s=column) } colnames(count.table) \u0026lt;- samples write.table(count.table,file = \u0026#34;count_table_chr18.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;,quote = F) #save as txt file 2、用DESeq包进行差异分析，差异基因存储在sig.deseq变量中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (!require(DESeq2)) BiocManager::install(\u0026#34;DESeq2\u0026#34;) library(DESeq2) d.raw \u0026lt;- read.delim(\u0026#34;count_table_chr18.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;) d \u0026lt;- d.raw[rowSums(d.raw\u0026gt;3)\u0026gt;2,] grp \u0026lt;- c(rep(\u0026#34;GM\u0026#34;,3),rep(\u0026#34;hES\u0026#34;,4)) cData \u0026lt;- data.frame(celltype = as.factor(grp)) rownames(cData) \u0026lt;- colnames(d) d.deseq \u0026lt;- DESeqDataSetFromMatrix(countData = d,colData = cData,design = ~celltype) d.deseq \u0026lt;- DESeq(d.deseq) results(d.deseq) res \u0026lt;- results(d.deseq,c(\u0026#34;celltype\u0026#34;,\u0026#34;hES\u0026#34;,\u0026#34;GM\u0026#34;)) sig \u0026lt;- res[which(res$padj \u0026lt; 0.01),] sig.deseq \u0026lt;- rownames(sig) 3、除此之外，还可以用不同的包进行分析，最后将几种方法得出的差异基因取交集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #limma if (!require(limma)) install.packages(\u0026#34;limma\u0026#34;) library(limma) grp \u0026lt;- c(\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;hES\u0026#34;,\u0026#34;hES\u0026#34;,\u0026#34;hES\u0026#34;,\u0026#34;hES\u0026#34;) des \u0026lt;- model.matrix(~0+grp) colnames(des) \u0026lt;- c(\u0026#34;GM\u0026#34;,\u0026#34;hES\u0026#34;) contrast.matrix \u0026lt;- makeContrasts(GM-hES,levels=des) d.norm \u0026lt;- voom(d,design=des) fit \u0026lt;- lmFit(d.norm,des) fit2 \u0026lt;- contrasts.fit(fit,contrast.matrix) fit2 \u0026lt;- eBayes(fit2) topTable(fit2,adjust=\u0026#34;BH\u0026#34;) all \u0026lt;- topTable(fit2,adjust.method=\u0026#34;BH\u0026#34;,number=10000) sig \u0026lt;- all[all$adj.P.Val \u0026lt; 1e-2,] sig.limma \u0026lt;- rownames(sig) limma \u0026lt;- rownames(sig) #samr if (!require(samr)) install.packages(\u0026#34;samr\u0026#34;) if (!require(impute)) BiocManager::install(\u0026#34;impute\u0026#34;) library(samr) num.grp \u0026lt;- c(rep(1,3),rep(2,4)) samfit \u0026lt;- SAMseq(d,num.grp,resp.type=\u0026#34;Two class unpaired\u0026#34;,genenames=rownames(d),random.seed=101010,fdr.output=0.01,nperms=1000) sig.sam \u0026lt;- c(samfit$siggenes.table$genes.up[,1],samfit$siggenes.table$genes.lo[,1]) #edgeR if (!require(edgeR)) install.packages(\u0026#34;edgeR\u0026#34;) library(edgeR) edgeR.dgelist = DGEList(counts=d,group=factor(grp)) edgeR.dgelist = calcNormFactors(edgeR.dgelist,method=\u0026#34;TMM\u0026#34;) edgeR.dgelist = estimateCommonDisp(edgeR.dgelist) edgeR.dgelist = estimateTagwiseDisp(edgeR.dgelist,trend = \u0026#34;movingave\u0026#34;) edgeR.test = exactTest(edgeR.dgelist) edgeR.pvalues = edgeR.test$table$PValue edgeR.adjpvalues = p.adjust(edgeR.pvalues,method=\u0026#34;BH\u0026#34;) sig.table \u0026lt;- edgeR.test$table[which(edgeR.adjpvalues \u0026lt;0.01),] sig.edgeR \u0026lt;- rownames(sig.table) 4、进行可视化处理，包括：进行主成分分析判断两组数据有何差异；对四种分析方法分析出的差异基因做Venn图并找出共有的差异基因；绘制热图可视化基因表达；绘制火山图进一步筛选基因。\n主成分分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # PCA GENE fig.A1 if (!require(ggbiplot)) install.packages(\u0026#34;ggbiplot\u0026#34;) library(ggbiplot) ct \u0026lt;- count.table[rownames(count.table) %in% sig.deseq,] ct = t(scale(t(ct))) ct.pca \u0026lt;- prcomp(ct,scale.=TRUE) ggbiplot( ct.pca, choices=c(1,2), obs.scale=1, var.scale=1, var.axes=T, varname.size = 2, varname.adjust = 2, )+ theme_bw()+ theme( legend.direction = \u0026#39;horizontal\u0026#39;, legend.position = \u0026#39;top\u0026#39;, legend.text = element_text(size = 10), legend.title = element_text(size = 10) ) ggsave(\u0026#39;pca_gene.pdf\u0026#39;,width=5,height=5,family=\u0026#34;GB1\u0026#34;) # PCA TYPE fig.A2 coln = colnames(ct) rown = rownames(ct) ct=t(ct) #Transpose colnames(ct)=rown rownames(ct)=coln ct \u0026lt;- ct[, colSums(ct != 0) \u0026gt; 0] ct.pca \u0026lt;- prcomp(ct,scale.=TRUE) ggbiplot( ct.pca, choices=c(1,2), obs.scale=1, var.scale=1, var.axes=F, labels=c(rownames(ct)), groups=c(\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;) , ellipse = TRUE, ellipse.prob = 0.95, )+ scale_color_manual(values=c(\u0026#39;#70abd8\u0026#39;,\u0026#39;#fb9b8e\u0026#39;))+ theme_bw()+ theme( legend.direction = \u0026#39;horizontal\u0026#39;, legend.position = \u0026#39;top\u0026#39;, legend.text = element_text(size = 10), legend.title = element_text(size = 10) ) ggsave(\u0026#39;pca_type.pdf\u0026#39;,width=5,height=5,family=\u0026#34;GB1\u0026#34;) 画出四组差异基因的Venn图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Venn Graph fig.B if (!require(VennDiagram)) BiocManager::install(\u0026#34;VennDiagram\u0026#34;) library(VennDiagram) gene.list = list(sig.deseq,sig.limma,sig.edgeR,sig.sam) venn1 \u0026lt;- venn.diagram( gene.list, category.names = c(\u0026#34;deseq\u0026#34;,\u0026#34;limma\u0026#34;,\u0026#34;edgeR\u0026#34;,\u0026#34;sam\u0026#34;), alpha = 0.5, cex = 2, cat.cex = 2, cat.fontface = \u0026#34;bold\u0026#34;, lty = 2, cat.pos = 0, filename = NULL, resolution = 300, fill = c(\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;yellow\u0026#34;), compression = \u0026#34;lzw\u0026#34; ) pdf(\u0026#34;venn.pdf\u0026#34;,width = 10,height = 10) grid.draw(venn1) dev.off() 对差异基因绘制热图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Pheat map fig.C1 if (!require(pheatmap)) install.packages(\u0026#34;pheatmap\u0026#34;) library(pheatmap) save_pheatmap_pdf \u0026lt;- function(x, filename, width=7, height=7) { stopifnot(!missing(x)) stopifnot(!missing(filename)) pdf(filename, width=width, height=height) grid::grid.newpage() grid::grid.draw(x$gtable) dev.off() } common_diff_genes \u0026lt;- Reduce(intersect, list(sig.deseq,sig.edgeR,sig.limma,sig.sam)) ct \u0026lt;- count.table[rownames(count.table) %in% common_diff_genes,] ct = t(scale(t(ct))) annotation_col \u0026lt;- data.frame( celltype = c(\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;GM\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;,\u0026#34;H1\u0026#34;) ) rownames(annotation_col) \u0026lt;- colnames(ct) pm \u0026lt;- pheatmap( ct, fontsize = 10, fontsize_row = 2, fontsize_col = 2, display_numbers = F, annotation_col = annotation_col, color = colorRampPalette(colors = c(\u0026#34;blue\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;red\u0026#34;))(100) ) save_pheatmap_pdf(pm, \u0026#34;C:\\\\Users\\\\admin\\\\Desktop\\\\Rscripts\\\\pheatmap.pdf\u0026#34;,6,12) # Pheat map fig.C2 pdf(\u0026#34;hm2.pdf\u0026#34;,width=5,height=5) heatmap(cor(ct),cexCol=0.75,cexRow=0.75) dev.off() 绘制火山图、可视化差异基因的log2FC和P值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 expr_matrix \u0026lt;- count.table[rownames(count.table) %in% common_diff_genes,] GM_samples \u0026lt;- 1:3 # 前三列为 GM H1_samples \u0026lt;- 4:7 # 后四列为 H1 sig2 \u0026lt;- sig[rownames(sig) %in% common_diff_genes,] Gene_table = data.frame(rownames(sig2),sig2$logFC,sig2$adj.P.Val) rownames(Gene_table) = Gene_table$rownames.sig2. Gene_table = Gene_table[,-1] colnames(Gene_table) \u0026lt;- c(\u0026#34;log2FC\u0026#34;,\u0026#34;pvalue\u0026#34;) change = as.factor(ifelse(Gene_table$pvalue \u0026lt; 0.05 \u0026amp; abs(Gene_table$log2FC) \u0026gt; 1, ifelse(Gene_table$log2FC \u0026gt; 1 ,\u0026#39;Up\u0026#39;,\u0026#39;Down\u0026#39;),\u0026#39;No change\u0026#39;)) pdf(\u0026#34;vol.pdf\u0026#34;,width=5,height=5) ggplot(Gene_table,aes(log2FC, -log10(pvalue)))+ geom_hline(yintercept = -log10(0.05), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_vline(xintercept = c(-1,1), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_point(aes(color = change), size = 0.2, alpha = 0.5) + theme_bw(base_size = 12)+ ggsci::scale_color_jama() + theme(panel.grid = element_blank(), legend.position = \u0026#39;right\u0026#39;) dev.off() 图片 ","date":"2024-12-14T00:00:00Z","permalink":"https://Detarame-ding.github.io/p/rna%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%9A%84%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B/","title":"Rna测序分析的标准流程"},{"content":"数据集的准备 说明 首先在https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE224679下载GSM7029397_103_23_barcodes.tsv.gz、GSM7029397_103_23_features.tsv.gz、GSM7029397_103_23_matrix.mtx.gz；GSM7029398_103_26_barcodes.tsv.gz、GSM7029398_103_26_features.tsv.gz、GSM7029398_103_26_matrix.mtx.gz六个文件，其中前三个文件为有FAP家族史的肿瘤患者的单细胞测序文件，后三个文件为有FAP家族史的非肿瘤患者的单细胞测序文件。新建一个文件夹“scRNA”，并且在里面建立名为“tumor”和“normal”的文件夹，将前三个文件放入“tumor”文件夹，后三个文件放入“normal”文件夹。\n代码 1 2 3 4 5 6 7 8 9 if (!require(Seurat)){ BiocManager::install(\u0026#34;Seurat\u0026#34;) } library(Seurat) library(dplyr) library(ggplot2) library(ggsci) library(ggrepel) setwd(\u0026#34;D:\\\\scRNA\u0026#34;)#将下载好的文件放于此处，前三个文件放于tumor文件夹，后三个放于normal文件夹 读取数据并构建Seurat对象 说明 将“tumor”和“normal”文件夹中的“XXX_features.tsv.tz”，“XXX_barcodes.tsv.tz”，“XXX_matrix.mtx.tz”三个文件分别重命名为：“features.tsv.tz”，“barcodes.tsv.tz”，“matrix.mtx.tz”。这样才能被Read10X函数读取。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #用Read10X函数读取肿瘤样本的单细胞数据 scRNA_data_t \u0026lt;- Read10X(data.dir=\u0026#34;.\\\\tumor\u0026#34;) #Read10X函数要求文件夹里有三个文件：barcodes.tsv.tz、features.tsv.tz、matrix.mtx.tz，名字必须一致 #这三个文件分别是单细胞的barcode、单细胞的注释信息以及表达矩阵 #读取的表达矩阵是用稀疏矩阵进行存储以节省空间,若想转为普通矩阵可以用as(x,\u0026#34;sparseMatrix\u0026#34;)进行转换 #查看log2x的分布情况，x是基因表达量，见fig.1A pdf(file=\u0026#34;hist1.pdf\u0026#34;,width = 5, height = 5) hist(log2(scRNA_data_t@x),breaks=100) dev.off() #得到该样本的基因名列表和细胞名列表 t_gene \u0026lt;- dimnames(scRNA_data_t)[[1]] t_cell \u0026lt;- dimnames(scRNA_data_t)[[2]] #构建metadata,即样本的注释信息 metadata_t = data.frame(row.names = t_cell) %\u0026gt;% mutate(sample = \u0026#39;GSE224679\u0026#39;, type = \u0026#39;Tumor\u0026#39;) #给每个细胞加上注释信息：属于GSE224679和Tumor组 #构建Seurat对象 srt1 \u0026lt;- CreateSeuratObject( counts = scRNA_data_t, #数据来源是用Read10X函数读入的scRNA_data_t meta.data = metadata_t, #指定细胞注释信息 min.cells = 3, #指定基因必须在3个及以上细胞中检测到 min.features = 200 #每个细胞至少表达200个基因才会被保留 ) #查看原始的counts矩阵 srt1@assays[[\u0026#39;RNA\u0026#39;]]@layers[[\u0026#39;counts\u0026#39;]] #V5中Seurat对象结构有改动，与以前的方法不一样 #提取基因名称 features = srt1@assays[[\u0026#39;RNA\u0026#39;]]@features features \u0026lt;- dimnames(features)[[1]] #读取normal文件夹的数据 scRNA_data_n \u0026lt;- Read10X(data.dir=\u0026#34;.\\\\normal\u0026#34;) pdf(file=\u0026#34;hist2.pdf\u0026#34;,width = 5, height = 5) hist(log2(scRNA_data_n@x),breaks=100) #fig.1B dev.off() n_gene \u0026lt;- dimnames(scRNA_data_n)[[1]] n_cell \u0026lt;- dimnames(scRNA_data_n)[[2]] metadata_n = data.frame(row.names = n_cell) %\u0026gt;% mutate(sample = \u0026#39;GSE224679\u0026#39;, type = \u0026#39;Normal\u0026#39;) srt2 \u0026lt;- CreateSeuratObject(counts = scRNA_data_n, meta.data = metadata_n, min.cells = 3, min.features = 200) #合并二个Seurat对象并保存 sc_merged \u0026lt;- merge(srt1,srt2) pbmc \u0026lt;- sc_merged save(pbmc,file=\u0026#34;merged_raw_counts.rda\u0026#34;) #查看pbmc中count和feature的分布情况 pdf(file=\u0026#34;nCount_RNA.pdf\u0026#34;,width = 5, height = 5) #统计每个细胞中测到的count总和的频数分布，fig1.C hist(pbmc$nCount_RNA) dev.off() pdf(file=\u0026#34;nFeature_RNA.pdf\u0026#34;,width = 5, height = 5) #统计每个细胞中有表达的基因的数量的频数分布，fig.1.D hist(pbmc$nFeature_RNA) dev.off() 图片 质量控制 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #查看线粒体基因频数分布图，pattern参数是指匹配MT开头的基因,fig.2.A pbmc$Percent.Mito \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^MT-\u0026#39;) pdf(file=\u0026#34;Percent.mito.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.Mito) dev.off() #查看外源基因频数分布图,匹配以ERCC开头的基因，fig.2.B pbmc$Percent.ERCC \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^ERCC\u0026#39;) pdf(file=\u0026#34;Percent.ERCC.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.ERCC) dev.off() #查看核糖体基因频数分布图,匹配以RPS或RPL开头的基因，fig.2.C pbmc$Percent.Ribo \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^RP[SL]\u0026#39;) pdf(file=\u0026#34;Percent.Ribo.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.Ribo) dev.off() ###可视化### #小提琴图，可以指定对哪个变量进行画图，以及指定分组依据。可以指定seurat对象中的metadata中的类别进行分组,fig.2.D、fig.2.E、fig.2.F、fig.2.G pdf(file=\u0026#34;nFeature_RNA_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;nFeature_RNA\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;nCount_RNA_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;nCount_RNA\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 5000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;Percent.Ribo_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;Percent.Ribo\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;Percent.Mito_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;Percent.Mito\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() #散点图，用来看两个metadata之间的关系，这里p1看的是nFeature和nCount的关系，p2看的是Percent.Ribo和Percent.Mito之间的关系，fig.2.H p1 \u0026lt;- FeatureScatter(object = pbmc, group.by = \u0026#39;type\u0026#39;, raster = F, shuffle = T, pt.size = 0.05, feature1 = \u0026#34;nFeature_RNA\u0026#34;, feature2 = \u0026#34;nCount_RNA\u0026#34;)+ scale_color_igv()+ guides(color = guide_legend(override.aes = list(size = 4))) p2 \u0026lt;- FeatureScatter(object = pbmc, group.by = \u0026#39;type\u0026#39;, raster = F, shuffle = T, pt.size = 0.05, feature1 = \u0026#34;Percent.Ribo\u0026#34;, feature2 = \u0026#34;Percent.Mito\u0026#34;)+ scale_color_igv()+ guides(color = guide_legend(override.aes = list(size = 4))) #将两个图拼起来 p = p1 + p2;p ggsave(p,filename = \u0026#34;quality.pdf\u0026#34;,width = 10,height = 4.5) #进一步筛选数据 pbmc_scaled \u0026lt;- subset(pbmc,nCount_RNA\u0026gt;1000) #筛选nCount_RNA\u0026gt;1000的细胞 pbmc_scaled = subset(pbmc_scaled,nFeature_RNA\u0026gt;500)#筛选nFeature_RNA\u0026gt;500的细胞 pbmc_scaled = subset(pbmc_scaled,Percent.Mito\u0026lt;20)#筛选Percent.Mito\u0026lt;20的细胞 pbmc_scaled = subset(pbmc_scaled,Percent.Ribo\u0026lt;40)#筛选Percent.Ribo\u0026lt;40的细胞 dim(pbmc_scaled)#查看数据维数，即查看筛选后还有多少个细胞，多少个基因 图片 数据降维 说明 常见的降维方法有3种：主成分分析（PCA）、T-分布领域嵌入算法（t-SNE）和UMAP（统一流形逼近与投影）。三者数学原理大相径庭，但是作用都是将成千上万维的数据降低至二维（以便在二维平面上进行绘图），同时尽可能地保持高维空间内的分布特征。例如，高维空间中距离较远的点，在降至二维后距离仍应当较远，反之亦然。在本例中，对高维数据首先进行PCA降至30维，再使用t-SNE和UMAP算法，将该30维数据降至二维（直接用后两者降维可能会花费很长的时间）。此外，最终结果的展示和进一步分析推荐UMAP。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 pbmc \u0026lt;- pbmc_scaled pbmc \u0026lt;- NormalizeData(object = pbmc) #进行数据标准化，消除不同细胞之间的测序深度差异 pbmc \u0026lt;- FindVariableFeatures(object = pbmc) #提取高变异基因 pdf(file=\u0026#34;AVG-SV.pdf\u0026#34;,width = 8, height = 5) #查看每个基因的均值与标准差,fig.3.A VariableFeaturePlot(pbmc,cols=c(\u0026#39;grey\u0026#39;,\u0026#39;steelblue\u0026#39;))+ scale_y_log10() dev.off() pbmc \u0026lt;- ScaleData(object = pbmc)#进行数据缩放，将基因表达量缩放到均值为0，标准差为1 #可视化缩放后的data,fig.3.B pdf(file=\u0026#34;scaled_data.pdf\u0026#34;,width = 6, height = 5) hist(colSums(pbmc,slot=\u0026#39;scale.data\u0026#39;), breaks = 50, main = \u0026#39;Raw counts\u0026#39;) dev.off() #PCA pbmc \u0026lt;- RunPCA(object = pbmc) #进行主成分分析 pdf(file=\u0026#34;elbow.pdf\u0026#34;,width = 6, height = 5)#可视化不同主成分的贡献，fig.3C ElbowPlot(pbmc,ndims = 30) dev.off() #tSNE and UMAP降维，需要基于PCA的结果，用PCA的前30个主成分进行降维，最终降至二维 pbmc \u0026lt;- RunTSNE(pbmc,dims = 1:30,reduction = \u0026#39;pca\u0026#39;,reduction.name = \u0026#39;tsne\u0026#39;) pbmc \u0026lt;- RunUMAP(object = pbmc, dims = 1:30, reduction = \u0026#39;pca\u0026#39;,reduction.name = \u0026#39;umap\u0026#39;) pbmc \u0026lt;- FindNeighbors(object = pbmc, dims = 1:30, reduction = \u0026#39;pca\u0026#39;)#根据前30个主成分构建细胞间邻接图 pbmc \u0026lt;- FindClusters(object = pbmc,resolution = 1, cluster.name = \u0026#39;unintegrated_clusters\u0026#39;)#进行聚类（预聚类） pdf(file=\u0026#34;pca.pdf\u0026#34;,width = 6, height = 5) #绘制PCA图，fig.3.D DimPlot(object = pbmc, reduction = \u0026#34;pca\u0026#34;) dev.off() pdf(file=\u0026#34;tsne.pdf\u0026#34;,width = 6, height = 5) #绘制t-SNE图，fig.3.E DimPlot(object = pbmc, reduction = \u0026#34;tsne\u0026#34;) dev.off() pdf(file=\u0026#34;umap.pdf\u0026#34;,width = 6, height = 5) #绘制UMAP图，fig.3.F DimPlot(object = pbmc, reduction = \u0026#34;umap\u0026#34;) dev.off() #使用不同的metadata进行分类，并分别在umap图上进行标注 pdf(file=\u0026#34;multi_umap.pdf\u0026#34;,width = 12, height = 5) #fig.3.F DimPlot(object = pbmc, reduction = \u0026#39;umap\u0026#39;, group.by = c(\u0026#39;type\u0026#39;,\u0026#39;unintegrated_clusters\u0026#39;), shuffle = T) dev.off() 图片 细胞分群 说明 根据细胞之间的亲疏关系（即以基因表达量为坐标，高维空间内的距离远近）进行聚类。Seurat包中聚类方法是基于K临近算法（KNN算法）开发的。通过比较不同分辨率（resolution）下的分类情况，选择合适的分辨率作为最终的分类方法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #载入clustree包 if (!require(clustree)){ BiocManager::install(\u0026#34;clustree\u0026#34;) } library(clustree) pbmc_2 \u0026lt;- JoinLayers(pbmc)#将所有样本合在一起 pbmc_2 \u0026lt;- FindNeighbors(object = pbmc_2, dims = 1:30, reduction = \u0026#39;pca\u0026#39;) pbmc_2 \u0026lt;- FindClusters( object = pbmc_2, resolution = c(seq(0.1,1.0,0.1)) )#分辨率0.1、0.2、0.3、...、1.0分别进行聚类，共聚类十次。 #用clustree函数来可视化不同分辨率下的分类情况，fig.4.A pdf(file=\u0026#34;clustree.pdf\u0026#34;,width = 6, height = 8) clustree(pbmc_2@meta.data,prefix = \u0026#39;RNA_snn_res.\u0026#39;) dev.off() #查看不同分群情况下的umap图结果，fig.4.B p1 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.2\u0026#34;, label = T, repel = F, shuffle = T);p1 p2 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.3\u0026#34;, label = T, repel = F, shuffle = T);p2 p3 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.4\u0026#34;, label = T, repel = F, shuffle = T);p3 p4 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.5\u0026#34;, label = T, repel = F, shuffle = T);p4 p5 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.6\u0026#34;, label = T, repel = F, shuffle = T);p5 p6 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.1\u0026#34;, label = T, repel = F, shuffle = T);p6 p = p1+p2+p3+p4+p5+p6 ggsave(p,filename = \u0026#34;quality2.pdf\u0026#34;,width = 13,height = 8) #选择合适的分辨率，这里选择0.5，共分为15类，这便是最终的分类 pbmc_2$seurat_clusters = pbmc_2$RNA_snn_res.0.5 #绘制resolution=0.5时的最终umap图像，fig.4.C p1 \u0026lt;- UMAPPlot(pbmc_2, label = T, repel = F, group.by = \u0026#39;seurat_clusters\u0026#39; )+ ggtitle(\u0026#39;UMAP\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_igv();p1 ggsave(p1,filename = \u0026#34;final_umap.pdf\u0026#34;,width = 13,height = 8) Idents(pbmc_2) = \u0026#39;seurat_clusters\u0026#39; 设置metadata中默认索引是‘seurat_clusters’ 图片 差异基因提取 说明 使用FindAllMarkers函数提取每一组内的差异表达基因，分组依据是上述的resolution=0.5时的自动分组，即‘Seurat clusters’，也就是Idents(pbmc_2)。接着提取每组中差异表达最明显的3个基因提取出来，将它们在每一组细胞内的表达情况用热图、气泡图或小提琴图展示出来。注意！这三种图包含着同样的信息，选取一个即可。\n此外，FeaturePlot函数允许指定多个基因，并可视化这些基因在细胞中的表达情况，可以选择感兴趣的基因进行绘图。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 sc.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, #保留上调与下调的基因 test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcoxn检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #该基因在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #这个函数里没有指定分组，则它会使用默认分组依据，即Idents(pbmc_2) save(sc.markers,file = \u0026#39;ALL_MARKERS.rda\u0026#39;) #取出每群表达中top3高的基因 top3 \u0026lt;- sc.markers %\u0026gt;% filter(avg_log2FC \u0026gt; 0) %\u0026gt;% group_by(cluster) %\u0026gt;% #以metadata中的‘cluster’来进行分类 filter(p_val_adj \u0026lt; 0.05) %\u0026gt;% top_n(3,avg_log2FC) %\u0026gt;% group_by() ###差异基因可视化### #各绘图方式信息量一致，选择一种即可 #热图，fig.5.A DoHeatmap( object = pbmc_2, features = top3$gene, label = TRUE )+ scale_fill_gradient(low = \u0026#39;lightgrey\u0026#39;,high = \u0026#39;salmon\u0026#39;) ggsave(file = \u0026#39;Heatmap.pdf\u0026#39;,width = 10,height = 8) #点图，fig.5.B DotPlot( object = pbmc_2, group.by = \u0026#39;seurat_clusters\u0026#39;, cols = c(\u0026#39;lightgrey\u0026#39;,\u0026#39;salmon\u0026#39;), features = unique(top3$gene) )+ coord_flip() ggsave(file = \u0026#39;dotplot.pdf\u0026#39;,width = 10,height = 8) #小提琴图，fig.5.C VlnPlot( object = pbmc_2, group.by = \u0026#39;seurat_clusters\u0026#39;, #fill.by = \u0026#39;feature\u0026#39;, stack = T, flip = T, features = unique(top3$gene) )+ scale_fill_igv() ggsave(file = \u0026#39;vlnplot.pdf\u0026#39;,width = 10,height = 8) #对于感兴趣的基因进行绘图,fig.5.D FeaturePlot( pbmc_2, features = c(\u0026#39;CD8A\u0026#39;,\u0026#39;CD4\u0026#39;,\u0026#39;ZNF683\u0026#39;,\u0026#39;OLFM4\u0026#39;),#可以选择感兴趣的基因进行绘图 order = T, alpha = 0.3, reduction = \u0026#39;umap\u0026#39; ) ggsave(file = \u0026#39;Featureplot.pdf\u0026#39;,width = 10,height = 8) 图片 细胞注释 说明 细胞注释，即根据细胞高表达的基因的特征来为其指定一种细胞类型。所研究的marker基因可以参考相关文献、参考前人的经验、或者从CellMarker官网导出等。本例中，与免疫细胞相关的marker基因来源于别人总结好的经验，与肠道细胞相关的marker基因是从CellMarker官网上导出的：\n在CellMarker2.0网站上检索肠道的分子Marker，在检索页面依次选择human\u0026ndash;gastrointestinal tract\u0026ndash;all，导出Table.csv，这里面便包含了肠道细胞的Marker基因。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 immune_markers = c(\u0026#39;CD8A\u0026#39;,\u0026#39;CD88\u0026#39;,\u0026#39;CD3D\u0026#39;,\u0026#39;CD3E\u0026#39;, #CD8+T \u0026#39;CD4\u0026#39;, #CD4+T \u0026#39;ZNF683\u0026#39;, #NKT \u0026#39;NKG7\u0026#39;,\u0026#39;FCER1G\u0026#39;,\u0026#39;FGFBP2\u0026#39;,\u0026#39;FCGR3A\u0026#39;,\u0026#39;GZMH\u0026#39;,\u0026#39;TYROBP\u0026#39;,\u0026#39;IGFBP7\u0026#39;,\u0026#39;CD160\u0026#39;,\u0026#39;GZMB\u0026#39;, #NK \u0026#39;CD74\u0026#39;,\u0026#39;CD79A\u0026#39;,\u0026#39;CD79B\u0026#39;,\u0026#39;MS4A1\u0026#39;, #B cells \u0026#39;JCHAIN\u0026#39;,\u0026#39;MZB1\u0026#39;,\u0026#39;IGHG1\u0026#39;, #Plasma cells \u0026#39;LYZ\u0026#39;,\u0026#39;S100A8\u0026#39;,\u0026#39;S100A9\u0026#39;,\u0026#39;CD14\u0026#39;, #monocyte \u0026#39;PPBP\u0026#39; #platelet )#这个是参照他人整理好的内容 #再从CellMarker2.0网站上检索肠道的分子Marker，选择human-gastrointestinal tract-all，导出Table.csv marker \u0026lt;- read.csv(\u0026#34;Table.csv\u0026#34;) marker \u0026lt;- marker$Cell.marker #绘制气泡图，fig.6.A plotdt = sc.markers %\u0026gt;% filter(gene %in% c(c(marker),c(immune_markers))) %\u0026gt;% arrange(cluster,avg_log2FC) %\u0026gt;% mutate(gene = factor(gene,levels = unique(gene),ordered = T)) ggplot( plotdt, aes(x = cluster,y = gene, size = avg_log2FC, color = pct.1))+ geom_point()+ geom_text(aes(label = cluster),size = 3,color = \u0026#39;black\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_gradient2(low = \u0026#39;olivedrab\u0026#39;,high = \u0026#39;salmon\u0026#39;, mid = \u0026#39;yellow\u0026#39;,midpoint = 0.5) ggsave(file = \u0026#39;Featureplot_intestine_marker.pdf\u0026#39;,width = 10,height = 8) #对特定的基因（这里可以是查找出来的某些差异基因）进行feature plot，fig.6.B FeaturePlot( pbmc_2, features = c(\u0026#39;KLRD1\u0026#39;,\u0026#39;TPSAB1\u0026#39;,\u0026#39;KIT\u0026#39;,\u0026#39;CD4\u0026#39;,\u0026#39;JCHAIN\u0026#39;,\u0026#39;MUC2\u0026#39;,\u0026#39;SELL\u0026#39;,\u0026#39;MS4A1\u0026#39;,\u0026#39;GUCA2B\u0026#39;,\u0026#39;CD3G\u0026#39;,\u0026#39;OLFM4\u0026#39;), order = T, alpha = 0.3, reduction = \u0026#39;umap\u0026#39; ) ggsave(file = \u0026#39;all_feature.pdf\u0026#39;,width = 10,height = 8) #手工细胞注释，根据cell marker，用肉眼大致看一下是哪种细胞的marker，然后手工给每群细胞打上标记。不过这种方式并不一定准确 pbmc_2$cell_type = case_when( pbmc_2$seurat_clusters %in% c(14) ~ \u0026#39;Mast cells\u0026#39;, pbmc_2$seurat_clusters %in% c(13) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(12) ~ \u0026#39;CD4+T cells\u0026#39;, pbmc_2$seurat_clusters %in% c(11) ~ \u0026#39;Plasma cells\u0026#39;, pbmc_2$seurat_clusters %in% c(10) ~ \u0026#39;Intestinal epithelial cells\u0026#39;, pbmc_2$seurat_clusters %in% c(5,7) ~ \u0026#39;B cells\u0026#39;, pbmc_2$seurat_clusters %in% c(8) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(9) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(1,2,3,4) ~ \u0026#39;Tumor cells\u0026#39;, pbmc_2$seurat_clusters %in% c(6) ~ \u0026#39;T cells\u0026#39;, pbmc_2$seurat_clusters %in% c(0) ~ \u0026#39;NK cells\u0026#39;, TRUE ~ \u0026#39;Unknown\u0026#39; ) p1 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;seurat_clusters\u0026#34;, label = T, repel = F, shuffle = T) p2 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;cell_type\u0026#34;, label = T, repel = F, shuffle = T) p3 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;type\u0026#34;, label = T, repel = F, shuffle = T) p = p1+p2+p3 ggsave(p,filename = \u0026#34;contrast_umap.pdf\u0026#34;,width = 24,height = 8)#fig.6.C ###对pbmc_2的meta.data可视化### #观察不同的细胞类型在肿瘤病人和正常病人之间的丰度比较，fig.6.D plotdata = pbmc_2@meta.data p \u0026lt;- ggplot( plotdata, aes(x=cell_type,fill = type) )+ geom_bar(position = \u0026#39;dodge\u0026#39;)+ scale_fill_igv(alpha = 0.7) ggsave(p,filename = \u0026#34;barplot.pdf\u0026#34;,width = 10,height = 6) #观察两类病人的不同细胞的构成比，fig.6.E p \u0026lt;- ggplot( plotdata, aes(x=type,fill = cell_type) )+ geom_bar(position = \u0026#39;fill\u0026#39;)+ scale_fill_igv(alpha = 0.7) ggsave(p,filename = \u0026#34;comparasion_barplot.pdf\u0026#34;,width = 4,height = 8) #对两个样本分别绘制umap，fig.6.F p \u0026lt;- UMAPPlot(pbmc_2, label = T, repel = F, split.by = \u0026#39;type\u0026#39;, group.by = \u0026#39;cell_type\u0026#39; )+ ggtitle(\u0026#39;UMAP\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_igv() ggsave(p,filename = \u0026#34;splited_umap.pdf\u0026#34;,width = 15,height = 8) 图片 注释后差异基因可视化 说明 与上述寻找差异基因的过程类似，不过这次已经注释好了细胞类型，可以再次绘制差异表达基因的火山图、热图等，或者提取某一种特定的细胞，研究其在不同组间的表达差异。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #之前寻找差异基因的时候用的是自动生成的unintegrated_cluster作为分类依据，现在用注释好的cell_type作为分类依据 Idents(pbmc_2) \u0026lt;- \u0026#34;cell_type\u0026#34; #将cell_type设置为主要的分类标签 #FindAllMarkers函数会分析每个Idents中的差异表达基因 cell.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, #保留上调与下调的基因 test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcox检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #FindMarkers函数通过指定分组依据（group.by），以及两个ident，来寻找这两个ident之间的差异基因 degs = FindMarkers( pbmc_2, logfc.threshold = 0.5, only.pos = F, ident.1 = \u0026#39;Tumor cells\u0026#39;, ident.2 = \u0026#39;Intestinal epithelial cells\u0026#39;,#默认使用ident1 vs ident2，而不是相反 group.by = \u0026#39;cell_type\u0026#39; ) %\u0026gt;% mutate(gene=rownames(.))#将基因名等于行名方便后续操作 #如果想要观察特定细胞类型的差异基因，可以先提取子集，然后做类似操作。比如这里选择分析T细胞 Tcell_subtype = subset(pbmc_2 , cell_type == \u0026#39;T cells\u0026#39;) Tcell_degs = FindMarkers( Tcell_subtype, logfc.threshold = 0.5, only.pos = F, ident.1 = \u0026#39;Tumor\u0026#39;, ident.2 = \u0026#39;Normal\u0026#39;, group.by = \u0026#39;type\u0026#39; ) %\u0026gt;% mutate(gene=rownames(.)) ###可视化### #火山图 #对degs可视化，fig.7.A change = as.factor(ifelse(degs$p_val_adj \u0026lt; 0.05 \u0026amp; abs(degs$avg_log2FC) \u0026gt; 1, ifelse(degs$avg_log2FC \u0026gt; 1 ,\u0026#39;Up\u0026#39;,\u0026#39;Down\u0026#39;),\u0026#39;No change\u0026#39;))#标记上调下调基因 filtered_degs = degs %\u0026gt;% filter(p_val_adj\u0026lt;1e-100)%\u0026gt;% filter(abs(avg_log2FC)\u0026gt;3) degs$label \u0026lt;- ifelse(degs$gene %in% filtered_degs$gene, degs$gene, NA)#标记相当显著的基因 pdf(\u0026#34;Tumor_vs_Unknown_vol.pdf\u0026#34;,width=5,height=5)#绘制Tumor cells和Unknown组之间的差异基因 ggplot(degs, aes(avg_log2FC, -log10(p_val_adj)))+ geom_hline(yintercept = -log10(0.05), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_vline(xintercept = c(-1,1), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_point(aes(color = change), size = 0.2, alpha = 0.5) + theme_bw(base_size = 12)+ geom_text_repel(aes(label = label), size = 3, box.padding = 0.2, max.overlaps = 10) + # 防止重叠 scale_color_manual(values = c(\u0026#34;Up\u0026#34; = \u0026#34;red\u0026#34;, \u0026#34;Down\u0026#34; = \u0026#34;blue\u0026#34;, \u0026#34;No change\u0026#34; = \u0026#34;gray\u0026#34;))+ theme(panel.grid = element_blank(), legend.position = \u0026#39;right\u0026#39;)+ scale_x_continuous(limits = c(-max(abs(degs$avg_log2FC)), max(abs(degs$avg_log2FC))))#沿y轴对称 dev.off() #对Tcells在肿瘤组和正常组之间的差异表达基因进行可视化，fig.7.B change = as.factor(ifelse(Tcell_degs$p_val_adj \u0026lt; 0.05 \u0026amp; abs(Tcell_degs$avg_log2FC) \u0026gt; 1, ifelse(Tcell_degs$avg_log2FC \u0026gt; 1 ,\u0026#39;Up\u0026#39;,\u0026#39;Down\u0026#39;),\u0026#39;No change\u0026#39;)) filtered_Tcell_degs = Tcell_degs %\u0026gt;% filter(p_val_adj\u0026lt; 0.05 )%\u0026gt;% filter(abs(avg_log2FC)\u0026gt;1) Tcell_degs$label \u0026lt;- ifelse(Tcell_degs$gene %in% filtered_Tcell_degs$gene, Tcell_degs$gene, NA) pdf(\u0026#34;T_vol.pdf\u0026#34;,width=5,height=5) ggplot(Tcell_degs, aes(avg_log2FC, -log10(p_val_adj)))+ geom_hline(yintercept = -log10(0.05), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_vline(xintercept = c(-1,1), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_point(aes(color = change), size = 0.2, alpha = 0.5) + theme_bw(base_size = 12)+ geom_text_repel(aes(label = label), size = 3, box.padding = 0.2, max.overlaps = 10) + # 防止重叠 scale_color_manual(values = c(\u0026#34;Up\u0026#34; = \u0026#34;red\u0026#34;, \u0026#34;Down\u0026#34; = \u0026#34;blue\u0026#34;, \u0026#34;No change\u0026#34; = \u0026#34;gray\u0026#34;))+ theme(panel.grid = element_blank(), legend.position = \u0026#39;right\u0026#39;)+ scale_x_continuous(limits = c(-max(abs(Tcell_degs$avg_log2FC)), max(abs(Tcell_degs$avg_log2FC)))) dev.off() #小提琴图，对每个类别的top3表达基因进行可视化，fig.7.C celldiff_top3 \u0026lt;- cell.markers %\u0026gt;% filter(avg_log2FC \u0026gt; 0) %\u0026gt;% group_by(cluster) %\u0026gt;% filter(avg_log2FC \u0026gt;3) %\u0026gt;% top_n(3,-p_val_adj) %\u0026gt;% group_by() VlnPlot(pbmc_2,features = celldiff_top3$gene, group.by = \u0026#34;cell_type\u0026#34;, split.plot = T, split.by = \u0026#39;type\u0026#39;, cols = c(\u0026#39;olivedrab\u0026#39;,\u0026#39;salmon\u0026#39;), stack = T, flip = T) ggsave(file = \u0026#39;vlnplot_celldiff_top3gene.pdf\u0026#39;,width = 8,height = 14) 图片 GO、KEGG、GSEA富集分析 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 library(tidyverse) library(clusterProfiler) library(enrichplot) Idents(pbmc_2) \u0026lt;- \u0026#34;cell_type\u0026#34; #将cell_type设置为主要的分类标签 cell.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcox检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #以cell_type为分类依据，寻找每个类别的差异表达基因 Tumor_degs = cell.markers %\u0026gt;% filter(cluster == \u0026#34;Tumor cells\u0026#34;) %\u0026gt;% filter(p_val_adj \u0026lt; 0.05) %\u0026gt;% filter(abs(avg_log2FC) \u0026gt; 1) %\u0026gt;% arrange(desc(avg_log2FC)) #过滤差异表达基因 GO_database \u0026lt;- \u0026#39;org.Hs.eg.db\u0026#39; #将SYMBOL转ENTREZID ENTgene \u0026lt;- bitr(Tumor_degs$gene, fromType = \u0026#39;SYMBOL\u0026#39;, toType = \u0026#39;ENTREZID\u0026#39;, OrgDb = GO_database,drop = F) %\u0026gt;% distinct(SYMBOL,.keep_all = T) %\u0026gt;% drop_na() ENTgene \u0026lt;- dplyr::distinct(ENTgene,SYMBOL,.keep_all = T) ###GO富集分析,使用enrichGO函数### GO \u0026lt;- enrichGO( ENTgene$ENTREZID, OrgDb = GO_database, #即\u0026#39;org.Hs.eg.db\u0026#39;，即人类数据库 keyType = \u0026#34;ENTREZID\u0026#34;, ont = \u0026#34;all\u0026#34;, # 获取BP, CC, MF所有本体论的富集结果 pvalueCutoff = 0.01, qvalueCutoff = 0.01, readable = T ) #可视化barplot，fig.8.A pdf(\u0026#34;GO_Enrichment_all_ontology.pdf\u0026#34;,width=8,height=12) barplot( GO, split=\u0026#34;ONTOLOGY\u0026#34;, #按基因本体论分组 )+ facet_wrap(~ONTOLOGY, scales=\u0026#34;free\u0026#34;, ncol=1) dev.off() #可视化dotplot，fig.8.B pdf(\u0026#34;GO_Enrichment_all_ontology_dot.pdf\u0026#34;,width=10,height=20) dotplot(GO,split = \u0026#34;ONTOLOGY\u0026#34;) dev.off() ###KEGG分析### KEGG_database = \u0026#39;hsa\u0026#39; kegg_data \u0026lt;- enrichKEGG( gene = ENTgene$ENTREZID, keyType = \u0026#39;kegg\u0026#39;, organism = KEGG_database, pvalueCutoff = 0.05, qvalueCutoff = 0.05, use_internal_data = F ) %\u0026gt;% setReadable(.,OrgDb = GO_database,keyType = \u0026#39;ENTREZID\u0026#39;) kegg_data = setReadable(kegg_data, #前面分析的结果 OrgDb = \u0026#34;org.Hs.eg.db\u0026#34;, #人类数据库 keyType = \u0026#34;ENTREZID\u0026#34;) #要转换的基因类型 write.table(kegg_data,file=\u0026#34;kegg_data.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;,quote=F,row.names = F) #可视化barplot，fig.8.C pdf(file=\u0026#34;kegg_barplot.pdf\u0026#34;,width = 7,height = 5) barplot(kegg_data, x = \u0026#34;GeneRatio\u0026#34;, color = \u0026#34;p.adjust\u0026#34;, #默认参数 showCategory =10) #只显示前10 dev.off() #可视化dotplot，fig.8.D pdf(file=\u0026#34;kegg_dotplot.pdf\u0026#34;,width = 7,height = 5) dotplot(kegg_data,x = \u0026#34;GeneRatio\u0026#34;, color = \u0026#34;p.adjust\u0026#34;, size = \u0026#34;Count\u0026#34;, #默认参数 showCategory = 10) dev.off() #可视化colored cnetplot，fig.8.E Tumor_degs$SYMBOL = Tumor_degs$gene cnet_data = merge(Tumor_degs,ENTgene,by = \u0026#34;SYMBOL\u0026#34;) cnet_data = data.frame(cnet_data$ENTREZID,cnet_data$gene,cnet_data$avg_log2FC) logFC \u0026lt;- cnet_data$cnet_data.avg_log2FC names(logFC) \u0026lt;- cnet_data$cnet_data.gene pdf(file=\u0026#34;colored_kegg_cnetplot.pdf\u0026#34;,width = 10,height = 10) cnetplot(kegg_data, showCategory = 8, #选择top8的pathway ，这里也可以用包含pathway名称的向量 foldChange = logFC, colorEdge = T, node_label = \u0026#39;all\u0026#39;, max.overlaps = 50 ) dev.off() ###GSEA分析### expr_matrix = data.frame(Tumor_degs$SYMBOL,Tumor_degs$avg_log2FC) colnames(expr_matrix) \u0026lt;- c(\u0026#34;SYMBOL\u0026#34;,\u0026#34;Log2FoldChange\u0026#34;) merged_matrix = merge(expr_matrix,ENTgene,by = \u0026#34;SYMBOL\u0026#34;) data_sort \u0026lt;- arrange(merged_matrix,desc(Log2FoldChange)) #log2FC进行排序，这是GSEA分析必要的 gene_list \u0026lt;- data_sort$Log2FoldChange names(gene_list) \u0026lt;- data_sort$ENTREZID KEGG_database = \u0026#39;hsa\u0026#39; gsea \u0026lt;- gseKEGG(gene_list,organism = KEGG_database, pvalueCutoff = 0.05) gsea = setReadable(gsea, OrgDb = GO_database, keyType = \u0026#34;ENTREZID\u0026#34;) #可视化 pdf(file=\u0026#34;gsea_dotplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.F dotplot(gsea) dev.off() pdf(file=\u0026#34;gsea_ridgeplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.G ridgeplot(gsea,label_format = 100) dev.off() pdf(file=\u0026#34;gsea_gseaplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.H gseaplot2(gsea,c(1:10),pvalue_table = F) dev.off() ###pathview图### library(pathview) library(tidyverse) pathview_data = Tumor_degs %\u0026gt;% filter(Tumor_degs$gene %in% as.factor(ENTgene$SYMBOL)) pathview_data$SYMBOL = pathview_data$gene pathview_data = merge(pathview_data,ENTgene,by = \u0026#39;SYMBOL\u0026#39;) pathview_data_draw = data.frame(pathview_data$ENTREZID,pathview_data$avg_log2FC) rownames(pathview_data_draw) = pathview_data_draw$pathview_data.ENTREZID colnames(pathview_data_draw) \u0026lt;- c(\u0026#39;ENTREZID\u0026#39;,\u0026#39;log2FC\u0026#39;) pathview_data_draw$ENTREZID \u0026lt;- as.numeric(pathview_data_draw$ENTREZID)#将ENTREZID列转化为数字 #绘图所需的数据是一个dataframe，行名是ENTREZID，两列分别是ENTREZID和log2FC #fig.8.I pathview(gene.data = pathview_data_draw, #上面包含行名为entrezID的logFC值的数据框 pathway.id = \u0026#34;hsa04390\u0026#34;, #选择一个KEGG信号通路,这里选的是hsa04650。更多通路见KEGG官网 species = \u0026#34;hsa\u0026#34;, out.suffix = \u0026#34;Tumor1\u0026#34;, #输出文件名 kegg.native = T ) #fig.8.J pathview(gene.data = pathview_data_draw, #上面包含行名为entrezID的logFC值的数据框 pathway.id = \u0026#34;hsa04390\u0026#34;, species = \u0026#34;hsa\u0026#34;, out.suffix = \u0026#34;Tumor2\u0026#34;, #输出文件名 kegg.native = F #以pdf保存，但是格式可能不好看 ) 图片 Cell Chat分析 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 if (!require(CellChat)){ devtools::install_github(\u0026#34;jinworks/CellChat\u0026#34;) devtools::install_github(\u0026#39;immunogenomics/presto\u0026#39;) } library(CellChat) library(patchwork) data.input \u0026lt;- pbmc_2[[\u0026#34;RNA\u0026#34;]]$data #提取表达矩阵 labels \u0026lt;- Idents(pbmc_2) #提取主要分类标签，这里是cell_type meta \u0026lt;- data.frame(labels = labels, row.names = names(labels)) cellchat \u0026lt;- createCellChat(object = pbmc_2, group.by = \u0026#34;ident\u0026#34;, assay = \u0026#34;RNA\u0026#34;) #构建cellchat对象 CellChatDB \u0026lt;- CellChatDB.human #选择人类数据库 #展示该数据库中的数据类别的构成比，fig.9.A showDatabaseCategory(CellChatDB) ggsave(filename=\u0026#39;DBcategory.pdf\u0026#39;,width = 6, height = 4) #提取数据库的子集，选择“Sevreted Signaling”部分 CellChatDB.use \u0026lt;- subsetDB(CellChatDB, search = \u0026#34;Secreted Signaling\u0026#34;, key = \u0026#34;annotation\u0026#34;) cellchat@DB \u0026lt;- CellChatDB.use #将数据库更新到cellchat对象中 cellchat \u0026lt;- subsetData(cellchat) #从输入数据中提取与信号通路相关的配体和受体基因，不能省略 cellchat \u0026lt;- identifyOverExpressedGenes(cellchat) #识别在各群体中过表达的基因 cellchat \u0026lt;- identifyOverExpressedInteractions(cellchat) #根据过表达基因推断潜在的细胞相互作用 #使用人类蛋白质相互作用（PPI）网络平滑信号数据，改进噪声模型 cellchat \u0026lt;- smoothData(cellchat, adj = PPI.human) #cellchat包作者把projectData函数改为了smoothData函数! cellchat \u0026lt;- computeCommunProb(cellchat, type = \u0026#34;triMean\u0026#34;) #计算细胞间的通信概率，使用三均值法作为估算方式 cellchat \u0026lt;- filterCommunication(cellchat, min.cells = 10) #筛选通信事件，保留至少在 10 个细胞中检测到的通信对 cellchat \u0026lt;- computeCommunProbPathway(cellchat) #计算细胞间通讯的路径概率 cellchat \u0026lt;- aggregateNet(cellchat)#将细胞间通讯的网络聚合到更高的层次 groupSize \u0026lt;- as.numeric(table(cellchat@idents))#计算每种细胞类型的细胞数 #绘制弦图，fig.9.B pdf(file=\u0026#34;Interactions_string.pdf\u0026#34;,width = 5,height = 5) netVisual_circle( cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = \u0026#34;Number of interactions\u0026#34; ) dev.off() #绘制弦图，线的粗细为weights/strength，fig.9.C pdf(file=\u0026#34;Interactions_string_W_S.pdf\u0026#34;,width = 5,height = 5) netVisual_circle( cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = \u0026#34;Interaction weights/strength\u0026#34; ) dev.off() #绘制每一个类型的细胞与所有的细胞之间的通讯情况，fig.9.D mat \u0026lt;- cellchat@net$weight pdf(file=\u0026#39;plot_all.pdf\u0026#39;,12,6) par(mfrow = c(2,4), xpd=TRUE) for (i in 1:nrow(mat)) { mat2 \u0026lt;- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat)) mat2[i, ] \u0026lt;- mat[i, ] netVisual_circle( mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i] ) } dev.off() #单独显示一条通路，这里选择MIF通路。绘制弦图，fig.9.E cellchat@netP$pathways#涉及到的所有的pathway pathways.show \u0026lt;- c(\u0026#34;MIF\u0026#34;) pdf(file = \u0026#39;MIF signaling pathway network2.pdf\u0026#39;,width = 5, height = 5) netVisual_aggregate( cellchat, signaling = pathways.show, ) dev.off() #绘制另一种弦图，fig.9.F pdf(file = \u0026#39;chord_plot.pdf\u0026#39;,width = 10,height = 10) netVisual_aggregate( cellchat, signaling = pathways.show, layout = \u0026#34;chord\u0026#34; ) dev.off() #绘制热图，fig.9.G pdf(file = \u0026#39;heatmap_plot.pdf\u0026#39;,width = 10,height = 10) netVisual_heatmap( cellchat, signaling = pathways.show, color.heatmap = \u0026#34;Reds\u0026#34; ) dev.off() #计算该通路（MIF）中一些亚型的贡献占比，fig.9.H pdf(file = \u0026#34;MIF_Sub.pdf\u0026#34;,width = 5,height = 5) netAnalysis_contribution(cellchat, signaling = pathways.show) dev.off() #提取MIF通路中所有亚型 pairLR.CXCR4 \u0026lt;- extractEnrichedLR( cellchat, signaling = pathways.show, geneLR.return = FALSE ) #提取MIF-（CD74+CRCX4）通路，画出某一条通路的弦图，fig.9.I LR.show \u0026lt;- pairLR.CXCR4[1,] # show one ligand-receptor pair pdf(file = \u0026#39;MIF-CD74+CRCX4_signaling_pathway.pdf\u0026#39;,width = 5,height = 5) netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show) dev.off() #可视化所有通路的亚型占比，fig.9.J pathways.show.all \u0026lt;- cellchat@netP$pathways vertex.receiver = seq(1,4) for (i in 1:length(pathways.show.all)) { # Visualize communication network associated with both signaling pathway and individual L-R pairs netVisual(cellchat, signaling = pathways.show.all[i], vertex.receiver = vertex.receiver, layout = \u0026#34;hierarchy\u0026#34;) # Compute and visualize the contribution of each ligand-receptor pair to the overall signaling pathway if (i==1){ gg \u0026lt;- netAnalysis_contribution(cellchat, signaling = pathways.show.all[i]) } gg \u0026lt;- gg+netAnalysis_contribution(cellchat, signaling = pathways.show.all[i]) #ggsave(filename=paste0(pathways.show.all[i], \u0026#34;_L-R_contribution.pdf\u0026#34;), plot=gg, width = 3, height = 2, units = \u0026#39;in\u0026#39;, dpi = 300) } ggsave(file = \u0026#39;contribution_of_each_pathway.pdf\u0026#39;,width = 14,height = 10) #绘制气泡图，本质与弦图类似，fig.9.K pdf(file = \u0026#39;bubble2.pdf\u0026#39;,width = 5,height = 5) netVisual_bubble( cellchat, sources.use = c(2), #指定信号来源的细胞群体 targets.use = c(1:8), #指定信号接收的细胞群体 signaling = c(\u0026#34;MIF\u0026#34;,\u0026#34;CypA\u0026#34;), #指定可视化哪些信号通路 remove.isolate = FALSE #不移除信号强度低的通信对 ) dev.off() #指定源细胞群和目标细胞群，以及指定信号通路，绘制弦图，fig.9.L pdf(file = \u0026#39;Tumor_to_all_chord.pdf\u0026#39;,width = 7,height = 5) netVisual_chord_gene( cellchat, sources.use = c(2), #指定信号来源的细胞群体，编号为 1 到 8。 targets.use = c(1:8), #指定信号接收的细胞群体，编号为 1 到 8。 signaling = c(\u0026#34;MIF\u0026#34;), legend.pos.x = 8 #调整图在画布上的位置 ) dev.off() #绘制与指定信号通路相关的基因的表达的小提琴图，fig.9.M pdf(file = \u0026#39;cell_chat_Vlnplot_MIF.pdf\u0026#39;,width = 7,height = 5) plotGeneExpression( cellchat, signaling = \u0026#34;MIF\u0026#34;, #指定一条信号通路 enriched.only = TRUE, #只显示显著上调的基因 type = \u0026#34;violin\u0026#34; #绘制小提琴图 ) dev.off() #计算信号网络中各细胞群体的中心性指标（如度数、介数和接近中心性等） cellchat \u0026lt;- netAnalysis_computeCentrality( cellchat, slot.name = \u0026#34;netP\u0026#34; #指定数据来源为概率加权信号网络netP ) #绘制图像，可视化在该通路下每个细胞的作用如何，分为Sender、Receiver、Mediator和Influencer，fig.9.N pdf(file = \u0026#39;SignalingRole_heatmap.pdf\u0026#39;,width = 7,height = 5) netAnalysis_signalingRole_network( cellchat, signaling = pathways.show, #指定绘图的信号通路，这里是MIF width = 8, height = 2.5, font.size = 10 ) dev.off() #生成热图，展示每个细胞群体在信号网络中作为发送者（Sender）和接收者（Receiver）的能力，fig.9.O ht1 \u0026lt;- netAnalysis_signalingRole_heatmap( cellchat, pattern = \u0026#34;outgoing\u0026#34; ) ht2 \u0026lt;- netAnalysis_signalingRole_heatmap( cellchat, pattern = \u0026#34;incoming\u0026#34; ) pdf(file = \u0026#39;O_R_heatmap.pdf\u0026#39;,width = 12,height = 7) ht1+ht2 dev.off() library(NMF) library(ggalluvial) ###outgoing### #有两个参数： #Cophenetic相关系数，用于衡量数据在聚类时的保真度（fidelity） #Silhouette系数衡量每个点在聚类中的紧密度和聚类之间的分离度 #fig.9.P K \u0026lt;- selectK(cellchat, pattern = \u0026#34;outgoing\u0026#34;) pdf(file = \u0026#39;K_out.pdf\u0026#39;,width = 12,height = 7) K dev.off() #绘制聚类热图，fig.9.Q pdf(file = \u0026#39;CommuPattern_out.pdf\u0026#39;,width = 12,height = 5) nPatterns = 3 cellchat \u0026lt;- identifyCommunicationPatterns(cellchat, pattern = \u0026#34;outgoing\u0026#34;, k = nPatterns) dev.off() #聚类-riverplot-out，fig.9.R pdf(file = \u0026#39;riverplot_out.pdf\u0026#39;,width = 12,height = 7) netAnalysis_river(cellchat, pattern = \u0026#34;outgoing\u0026#34;) dev.off() #聚类-dotplot-out，fig.9.S pdf(file = \u0026#39;dotplot_out.pdf\u0026#39;,width = 12,height = 7) netAnalysis_dot(cellchat, pattern = \u0026#34;outgoing\u0026#34;) dev.off() ###incoming### #fig.9.T K \u0026lt;- selectK(cellchat, pattern = \u0026#34;incoming\u0026#34;) pdf(file = \u0026#39;K_in.pdf\u0026#39;,width = 12,height = 7) K dev.off() #聚类热图，fig.9.U pdf(file = \u0026#39;CommuPattern_in.pdf\u0026#39;,width = 12,height = 5) nPatterns = 3 cellchat \u0026lt;- identifyCommunicationPatterns(cellchat, pattern = \u0026#34;incoming\u0026#34;, k = nPatterns) dev.off() #聚类-riverplot-in，fig.9.V pdf(file = \u0026#39;riverplot_in.pdf\u0026#39;,width = 12,height = 7) netAnalysis_river(cellchat, pattern = \u0026#34;incoming\u0026#34;) dev.off() #聚类-dotplot-in，fig.9.W pdf(file = \u0026#39;dotplot_in.pdf\u0026#39;,width = 12,height = 7) netAnalysis_dot(cellchat, pattern = \u0026#34;incoming\u0026#34;) dev.off() 图片 ","date":"2024-12-14T00:00:00Z","image":"https://Detarame-ding.github.io/p/%E5%9F%BA%E4%BA%8Eseurat%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B/seurat_banner_hu12300301024957807398.jpg","permalink":"https://Detarame-ding.github.io/p/%E5%9F%BA%E4%BA%8Eseurat%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B/","title":"基于Seurat的单细胞分析标准流程"}]