[{"content":"NULL ","date":"2024-12-14T00:00:00Z","permalink":"https://Detarame-ding.github.io/p/%E5%9F%BA%E5%9B%A0%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","title":"基因命名规范"},{"content":"数据集的准备 说明 首先在https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE224679下载GSM7029397_103_23_barcodes.tsv.gz、GSM7029397_103_23_features.tsv.gz、GSM7029397_103_23_matrix.mtx.gz；GSM7029398_103_26_barcodes.tsv.gz、GSM7029398_103_26_features.tsv.gz、GSM7029398_103_26_matrix.mtx.gz六个文件，其中前三个文件为有FAP家族史的肿瘤患者的单细胞测序文件，后三个文件为有FAP家族史的非肿瘤患者的单细胞测序文件。新建一个文件夹“scRNA”，并且在里面建立名为“tumor”和“normal”的文件夹，将前三个文件放入“tumor”文件夹，后三个文件放入“normal”文件夹。\n代码 1 2 3 4 5 6 7 8 9 if (!require(Seurat)){ BiocManager::install(\u0026#34;Seurat\u0026#34;) } library(Seurat) library(dplyr) library(ggplot2) library(ggsci) library(ggrepel) setwd(\u0026#34;D:\\\\scRNA\u0026#34;)#将下载好的文件放于此处，前三个文件放于tumor文件夹，后三个放于normal文件夹 读取数据并构建Seurat对象 说明 将“tumor”和“normal”文件夹中的“XXX_features.tsv.tz”，“XXX_barcodes.tsv.tz”，“XXX_matrix.mtx.tz”三个文件分别重命名为：“features.tsv.tz”，“barcodes.tsv.tz”，“matrix.mtx.tz”。这样才能被Read10X函数读取。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #用Read10X函数读取肿瘤样本的单细胞数据 scRNA_data_t \u0026lt;- Read10X(data.dir=\u0026#34;.\\\\tumor\u0026#34;) #Read10X函数要求文件夹里有三个文件：barcodes.tsv.tz、features.tsv.tz、matrix.mtx.tz，名字必须一致 #这三个文件分别是单细胞的barcode、单细胞的注释信息以及表达矩阵 #读取的表达矩阵是用稀疏矩阵进行存储以节省空间,若想转为普通矩阵可以用as(x,\u0026#34;sparseMatrix\u0026#34;)进行转换 #查看log2x的分布情况，x是基因表达量，见fig.1A pdf(file=\u0026#34;hist1.pdf\u0026#34;,width = 5, height = 5) hist(log2(scRNA_data_t@x),breaks=100) dev.off() #得到该样本的基因名列表和细胞名列表 t_gene \u0026lt;- dimnames(scRNA_data_t)[[1]] t_cell \u0026lt;- dimnames(scRNA_data_t)[[2]] #构建metadata,即样本的注释信息 metadata_t = data.frame(row.names = t_cell) %\u0026gt;% mutate(sample = \u0026#39;GSE224679\u0026#39;, type = \u0026#39;Tumor\u0026#39;) #给每个细胞加上注释信息：属于GSE224679和Tumor组 #构建Seurat对象 srt1 \u0026lt;- CreateSeuratObject( counts = scRNA_data_t, #数据来源是用Read10X函数读入的scRNA_data_t meta.data = metadata_t, #指定细胞注释信息 min.cells = 3, #指定基因必须在3个及以上细胞中检测到 min.features = 200 #每个细胞至少表达200个基因才会被保留 ) #查看原始的counts矩阵 srt1@assays[[\u0026#39;RNA\u0026#39;]]@layers[[\u0026#39;counts\u0026#39;]] #V5中Seurat对象结构有改动，与以前的方法不一样 #提取基因名称 features = srt1@assays[[\u0026#39;RNA\u0026#39;]]@features features \u0026lt;- dimnames(features)[[1]] #读取normal文件夹的数据 scRNA_data_n \u0026lt;- Read10X(data.dir=\u0026#34;.\\\\normal\u0026#34;) pdf(file=\u0026#34;hist2.pdf\u0026#34;,width = 5, height = 5) hist(log2(scRNA_data_n@x),breaks=100) #fig.1B dev.off() n_gene \u0026lt;- dimnames(scRNA_data_n)[[1]] n_cell \u0026lt;- dimnames(scRNA_data_n)[[2]] metadata_n = data.frame(row.names = n_cell) %\u0026gt;% mutate(sample = \u0026#39;GSE224679\u0026#39;, type = \u0026#39;Normal\u0026#39;) srt2 \u0026lt;- CreateSeuratObject(counts = scRNA_data_n, meta.data = metadata_n, min.cells = 3, min.features = 200) #合并二个Seurat对象并保存 sc_merged \u0026lt;- merge(srt1,srt2) pbmc \u0026lt;- sc_merged save(pbmc,file=\u0026#34;merged_raw_counts.rda\u0026#34;) #查看pbmc中count和feature的分布情况 pdf(file=\u0026#34;nCount_RNA.pdf\u0026#34;,width = 5, height = 5) #统计每个细胞中测到的count总和的频数分布，fig1.C hist(pbmc$nCount_RNA) dev.off() pdf(file=\u0026#34;nFeature_RNA.pdf\u0026#34;,width = 5, height = 5) #统计每个细胞中有表达的基因的数量的频数分布，fig.1.D hist(pbmc$nFeature_RNA) dev.off() 图片 质量控制 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #查看线粒体基因频数分布图，pattern参数是指匹配MT开头的基因,fig.2.A pbmc$Percent.Mito \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^MT-\u0026#39;) pdf(file=\u0026#34;Percent.mito.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.Mito) dev.off() #查看外源基因频数分布图,匹配以ERCC开头的基因，fig.2.B pbmc$Percent.ERCC \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^ERCC\u0026#39;) pdf(file=\u0026#34;Percent.ERCC.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.ERCC) dev.off() #查看核糖体基因频数分布图,匹配以RPS或RPL开头的基因，fig.2.C pbmc$Percent.Ribo \u0026lt;- PercentageFeatureSet(pbmc,pattern = \u0026#39;^RP[SL]\u0026#39;) pdf(file=\u0026#34;Percent.Ribo.pdf\u0026#34;,width = 5, height = 5) hist(pbmc$Percent.Ribo) dev.off() ###可视化### #小提琴图，可以指定对哪个变量进行画图，以及指定分组依据。可以指定seurat对象中的metadata中的类别进行分组,fig.2.D、fig.2.E、fig.2.F、fig.2.G pdf(file=\u0026#34;nFeature_RNA_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;nFeature_RNA\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;nCount_RNA_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;nCount_RNA\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 5000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;Percent.Ribo_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;Percent.Ribo\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() pdf(file=\u0026#34;Percent.Mito_VlnPlot.pdf\u0026#34;,width = 5, height = 5) VlnPlot(pbmc,features = \u0026#39;Percent.Mito\u0026#39;,group.by = \u0026#39;type\u0026#39;, alpha = 0.1,pt.size = 0.01)+ geom_hline(yintercept = 2000,color = \u0026#39;red\u0026#39;)+ scale_fill_igv() dev.off() #散点图，用来看两个metadata之间的关系，这里p1看的是nFeature和nCount的关系，p2看的是Percent.Ribo和Percent.Mito之间的关系，fig.2.H p1 \u0026lt;- FeatureScatter(object = pbmc, group.by = \u0026#39;type\u0026#39;, raster = F, shuffle = T, pt.size = 0.05, feature1 = \u0026#34;nFeature_RNA\u0026#34;, feature2 = \u0026#34;nCount_RNA\u0026#34;)+ scale_color_igv()+ guides(color = guide_legend(override.aes = list(size = 4))) p2 \u0026lt;- FeatureScatter(object = pbmc, group.by = \u0026#39;type\u0026#39;, raster = F, shuffle = T, pt.size = 0.05, feature1 = \u0026#34;Percent.Ribo\u0026#34;, feature2 = \u0026#34;Percent.Mito\u0026#34;)+ scale_color_igv()+ guides(color = guide_legend(override.aes = list(size = 4))) #将两个图拼起来 p = p1 + p2;p ggsave(p,filename = \u0026#34;quality.pdf\u0026#34;,width = 10,height = 4.5) #进一步筛选数据 pbmc_scaled \u0026lt;- subset(pbmc,nCount_RNA\u0026gt;1000) #筛选nCount_RNA\u0026gt;1000的细胞 pbmc_scaled = subset(pbmc_scaled,nFeature_RNA\u0026gt;500)#筛选nFeature_RNA\u0026gt;500的细胞 pbmc_scaled = subset(pbmc_scaled,Percent.Mito\u0026lt;20)#筛选Percent.Mito\u0026lt;20的细胞 pbmc_scaled = subset(pbmc_scaled,Percent.Ribo\u0026lt;40)#筛选Percent.Ribo\u0026lt;40的细胞 dim(pbmc_scaled)#查看数据维数，即查看筛选后还有多少个细胞，多少个基因 图片 数据降维 说明 常见的降维方法有3种：主成分分析（PCA）、T-分布领域嵌入算法（t-SNE）和UMAP（统一流形逼近与投影）。三者数学原理大相径庭，但是作用都是将成千上万维的数据降低至二维（以便在二维平面上进行绘图），同时尽可能地保持高维空间内的分布特征。例如，高维空间中距离较远的点，在降至二维后距离仍应当较远，反之亦然。在本例中，对高维数据首先进行PCA降至30维，再使用t-SNE和UMAP算法，将该30维数据降至二维（直接用后两者降维可能会花费很长的时间）。此外，最终结果的展示和进一步分析推荐UMAP。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 pbmc \u0026lt;- pbmc_scaled pbmc \u0026lt;- NormalizeData(object = pbmc) #进行数据标准化，消除不同细胞之间的测序深度差异 pbmc \u0026lt;- FindVariableFeatures(object = pbmc) #提取高变异基因 pdf(file=\u0026#34;AVG-SV.pdf\u0026#34;,width = 8, height = 5) #查看每个基因的均值与标准差,fig.3.A VariableFeaturePlot(pbmc,cols=c(\u0026#39;grey\u0026#39;,\u0026#39;steelblue\u0026#39;))+ scale_y_log10() dev.off() pbmc \u0026lt;- ScaleData(object = pbmc)#进行数据缩放，将基因表达量缩放到均值为0，标准差为1 #可视化缩放后的data,fig.3.B pdf(file=\u0026#34;scaled_data.pdf\u0026#34;,width = 6, height = 5) hist(colSums(pbmc,slot=\u0026#39;scale.data\u0026#39;), breaks = 50, main = \u0026#39;Raw counts\u0026#39;) dev.off() #PCA pbmc \u0026lt;- RunPCA(object = pbmc) #进行主成分分析 pdf(file=\u0026#34;elbow.pdf\u0026#34;,width = 6, height = 5)#可视化不同主成分的贡献，fig.3C ElbowPlot(pbmc,ndims = 30) dev.off() #tSNE and UMAP降维，需要基于PCA的结果，用PCA的前30个主成分进行降维，最终降至二维 pbmc \u0026lt;- RunTSNE(pbmc,dims = 1:30,reduction = \u0026#39;pca\u0026#39;,reduction.name = \u0026#39;tsne\u0026#39;) pbmc \u0026lt;- RunUMAP(object = pbmc, dims = 1:30, reduction = \u0026#39;pca\u0026#39;,reduction.name = \u0026#39;umap\u0026#39;) pbmc \u0026lt;- FindNeighbors(object = pbmc, dims = 1:30, reduction = \u0026#39;pca\u0026#39;)#根据前30个主成分构建细胞间邻接图 pbmc \u0026lt;- FindClusters(object = pbmc,resolution = 1, cluster.name = \u0026#39;unintegrated_clusters\u0026#39;)#进行聚类（预聚类） pdf(file=\u0026#34;pca.pdf\u0026#34;,width = 6, height = 5) #绘制PCA图，fig.3.D DimPlot(object = pbmc, reduction = \u0026#34;pca\u0026#34;) dev.off() pdf(file=\u0026#34;tsne.pdf\u0026#34;,width = 6, height = 5) #绘制t-SNE图，fig.3.E DimPlot(object = pbmc, reduction = \u0026#34;tsne\u0026#34;) dev.off() pdf(file=\u0026#34;umap.pdf\u0026#34;,width = 6, height = 5) #绘制UMAP图，fig.3.F DimPlot(object = pbmc, reduction = \u0026#34;umap\u0026#34;) dev.off() #使用不同的metadata进行分类，并分别在umap图上进行标注 pdf(file=\u0026#34;multi_umap.pdf\u0026#34;,width = 12, height = 5) #fig.3.F DimPlot(object = pbmc, reduction = \u0026#39;umap\u0026#39;, group.by = c(\u0026#39;type\u0026#39;,\u0026#39;unintegrated_clusters\u0026#39;), shuffle = T) dev.off() 图片 细胞分群 说明 根据细胞之间的亲疏关系（即以基因表达量为坐标，高维空间内的距离远近）进行聚类。Seurat包中聚类方法是基于K临近算法（KNN算法）开发的。通过比较不同分辨率（resolution）下的分类情况，选择合适的分辨率作为最终的分类方法。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #载入clustree包 if (!require(clustree)){ BiocManager::install(\u0026#34;clustree\u0026#34;) } library(clustree) pbmc_2 \u0026lt;- JoinLayers(pbmc)#将所有样本合在一起 pbmc_2 \u0026lt;- FindNeighbors(object = pbmc_2, dims = 1:30, reduction = \u0026#39;pca\u0026#39;) pbmc_2 \u0026lt;- FindClusters( object = pbmc_2, resolution = c(seq(0.1,1.0,0.1)) )#分辨率0.1、0.2、0.3、...、1.0分别进行聚类，共聚类十次。 #用clustree函数来可视化不同分辨率下的分类情况，fig.4.A pdf(file=\u0026#34;clustree.pdf\u0026#34;,width = 6, height = 8) clustree(pbmc_2@meta.data,prefix = \u0026#39;RNA_snn_res.\u0026#39;) dev.off() #查看不同分群情况下的umap图结果，fig.4.B p1 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.2\u0026#34;, label = T, repel = F, shuffle = T);p1 p2 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.3\u0026#34;, label = T, repel = F, shuffle = T);p2 p3 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.4\u0026#34;, label = T, repel = F, shuffle = T);p3 p4 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.5\u0026#34;, label = T, repel = F, shuffle = T);p4 p5 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.0.6\u0026#34;, label = T, repel = F, shuffle = T);p5 p6 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;RNA_snn_res.1\u0026#34;, label = T, repel = F, shuffle = T);p6 p = p1+p2+p3+p4+p5+p6 ggsave(p,filename = \u0026#34;quality2.pdf\u0026#34;,width = 13,height = 8) #选择合适的分辨率，这里选择0.5，共分为15类，这便是最终的分类 pbmc_2$seurat_clusters = pbmc_2$RNA_snn_res.0.5 #绘制resolution=0.5时的最终umap图像，fig.4.C p1 \u0026lt;- UMAPPlot(pbmc_2, label = T, repel = F, group.by = \u0026#39;seurat_clusters\u0026#39; )+ ggtitle(\u0026#39;UMAP\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_igv();p1 ggsave(p1,filename = \u0026#34;final_umap.pdf\u0026#34;,width = 13,height = 8) Idents(pbmc_2) = \u0026#39;seurat_clusters\u0026#39; 设置metadata中默认索引是‘seurat_clusters’ 图片 差异基因提取 说明 使用FindAllMarkers函数提取每一组内的差异表达基因，分组依据是上述的resolution=0.5时的自动分组，即‘Seurat clusters’，也就是Idents(pbmc_2)。接着提取每组中差异表达最明显的3个基因提取出来，将它们在每一组细胞内的表达情况用热图、气泡图或小提琴图展示出来。注意！这三种图包含着同样的信息，选取一个即可。\n此外，FeaturePlot函数允许指定多个基因，并可视化这些基因在细胞中的表达情况，可以选择感兴趣的基因进行绘图。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 sc.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, #保留上调与下调的基因 test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcoxn检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #该基因在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #这个函数里没有指定分组，则它会使用默认分组依据，即Idents(pbmc_2) save(sc.markers,file = \u0026#39;ALL_MARKERS.rda\u0026#39;) #取出每群表达中top3高的基因 top3 \u0026lt;- sc.markers %\u0026gt;% filter(avg_log2FC \u0026gt; 0) %\u0026gt;% group_by(cluster) %\u0026gt;% #以metadata中的‘cluster’来进行分类 filter(p_val_adj \u0026lt; 0.05) %\u0026gt;% top_n(3,avg_log2FC) %\u0026gt;% group_by() ###差异基因可视化### #各绘图方式信息量一致，选择一种即可 #热图，fig.5.A DoHeatmap( object = pbmc_2, features = top3$gene, label = TRUE )+ scale_fill_gradient(low = \u0026#39;lightgrey\u0026#39;,high = \u0026#39;salmon\u0026#39;) ggsave(file = \u0026#39;Heatmap.pdf\u0026#39;,width = 10,height = 8) #点图，fig.5.B DotPlot( object = pbmc_2, group.by = \u0026#39;seurat_clusters\u0026#39;, cols = c(\u0026#39;lightgrey\u0026#39;,\u0026#39;salmon\u0026#39;), features = unique(top3$gene) )+ coord_flip() ggsave(file = \u0026#39;dotplot.pdf\u0026#39;,width = 10,height = 8) #小提琴图，fig.5.C VlnPlot( object = pbmc_2, group.by = \u0026#39;seurat_clusters\u0026#39;, #fill.by = \u0026#39;feature\u0026#39;, stack = T, flip = T, features = unique(top3$gene) )+ scale_fill_igv() ggsave(file = \u0026#39;vlnplot.pdf\u0026#39;,width = 10,height = 8) #对于感兴趣的基因进行绘图,fig.5.D FeaturePlot( pbmc_2, features = c(\u0026#39;CD8A\u0026#39;,\u0026#39;CD4\u0026#39;,\u0026#39;ZNF683\u0026#39;,\u0026#39;OLFM4\u0026#39;),#可以选择感兴趣的基因进行绘图 order = T, alpha = 0.3, reduction = \u0026#39;umap\u0026#39; ) ggsave(file = \u0026#39;Featureplot.pdf\u0026#39;,width = 10,height = 8) 图片 细胞注释 说明 细胞注释，即根据细胞高表达的基因的特征来为其指定一种细胞类型。所研究的marker基因可以参考相关文献、参考前人的经验、或者从CellMarker官网导出等。本例中，与免疫细胞相关的marker基因来源于别人总结好的经验，与肠道细胞相关的marker基因是从CellMarker官网上导出的：\n在CellMarker2.0网站上检索肠道的分子Marker，在检索页面依次选择human\u0026ndash;gastrointestinal tract\u0026ndash;all，导出Table.csv，这里面便包含了肠道细胞的Marker基因。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 immune_markers = c(\u0026#39;CD8A\u0026#39;,\u0026#39;CD88\u0026#39;,\u0026#39;CD3D\u0026#39;,\u0026#39;CD3E\u0026#39;, #CD8+T \u0026#39;CD4\u0026#39;, #CD4+T \u0026#39;ZNF683\u0026#39;, #NKT \u0026#39;NKG7\u0026#39;,\u0026#39;FCER1G\u0026#39;,\u0026#39;FGFBP2\u0026#39;,\u0026#39;FCGR3A\u0026#39;,\u0026#39;GZMH\u0026#39;,\u0026#39;TYROBP\u0026#39;,\u0026#39;IGFBP7\u0026#39;,\u0026#39;CD160\u0026#39;,\u0026#39;GZMB\u0026#39;, #NK \u0026#39;CD74\u0026#39;,\u0026#39;CD79A\u0026#39;,\u0026#39;CD79B\u0026#39;,\u0026#39;MS4A1\u0026#39;, #B cells \u0026#39;JCHAIN\u0026#39;,\u0026#39;MZB1\u0026#39;,\u0026#39;IGHG1\u0026#39;, #Plasma cells \u0026#39;LYZ\u0026#39;,\u0026#39;S100A8\u0026#39;,\u0026#39;S100A9\u0026#39;,\u0026#39;CD14\u0026#39;, #monocyte \u0026#39;PPBP\u0026#39; #platelet )#这个是参照他人整理好的内容 #再从CellMarker2.0网站上检索肠道的分子Marker，选择human-gastrointestinal tract-all，导出Table.csv marker \u0026lt;- read.csv(\u0026#34;Table.csv\u0026#34;) marker \u0026lt;- marker$Cell.marker #绘制气泡图，fig.6.A plotdt = sc.markers %\u0026gt;% filter(gene %in% c(c(marker),c(immune_markers))) %\u0026gt;% arrange(cluster,avg_log2FC) %\u0026gt;% mutate(gene = factor(gene,levels = unique(gene),ordered = T)) ggplot( plotdt, aes(x = cluster,y = gene, size = avg_log2FC, color = pct.1))+ geom_point()+ geom_text(aes(label = cluster),size = 3,color = \u0026#39;black\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_gradient2(low = \u0026#39;olivedrab\u0026#39;,high = \u0026#39;salmon\u0026#39;, mid = \u0026#39;yellow\u0026#39;,midpoint = 0.5) ggsave(file = \u0026#39;Featureplot_intestine_marker.pdf\u0026#39;,width = 10,height = 8) #对特定的基因（这里可以是查找出来的某些差异基因）进行feature plot，fig.6.B FeaturePlot( pbmc_2, features = c(\u0026#39;KLRD1\u0026#39;,\u0026#39;TPSAB1\u0026#39;,\u0026#39;KIT\u0026#39;,\u0026#39;CD4\u0026#39;,\u0026#39;JCHAIN\u0026#39;,\u0026#39;MUC2\u0026#39;,\u0026#39;SELL\u0026#39;,\u0026#39;MS4A1\u0026#39;,\u0026#39;GUCA2B\u0026#39;,\u0026#39;CD3G\u0026#39;,\u0026#39;OLFM4\u0026#39;), order = T, alpha = 0.3, reduction = \u0026#39;umap\u0026#39; ) ggsave(file = \u0026#39;all_feature.pdf\u0026#39;,width = 10,height = 8) #手工细胞注释，根据cell marker，用肉眼大致看一下是哪种细胞的marker，然后手工给每群细胞打上标记。不过这种方式并不一定准确 pbmc_2$cell_type = case_when( pbmc_2$seurat_clusters %in% c(14) ~ \u0026#39;Mast cells\u0026#39;, pbmc_2$seurat_clusters %in% c(13) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(12) ~ \u0026#39;CD4+T cells\u0026#39;, pbmc_2$seurat_clusters %in% c(11) ~ \u0026#39;Plasma cells\u0026#39;, pbmc_2$seurat_clusters %in% c(10) ~ \u0026#39;Intestinal epithelial cells\u0026#39;, pbmc_2$seurat_clusters %in% c(5,7) ~ \u0026#39;B cells\u0026#39;, pbmc_2$seurat_clusters %in% c(8) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(9) ~ \u0026#39;Unknown\u0026#39;, pbmc_2$seurat_clusters %in% c(1,2,3,4) ~ \u0026#39;Tumor cells\u0026#39;, pbmc_2$seurat_clusters %in% c(6) ~ \u0026#39;T cells\u0026#39;, pbmc_2$seurat_clusters %in% c(0) ~ \u0026#39;NK cells\u0026#39;, TRUE ~ \u0026#39;Unknown\u0026#39; ) p1 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;seurat_clusters\u0026#34;, label = T, repel = F, shuffle = T) p2 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;cell_type\u0026#34;, label = T, repel = F, shuffle = T) p3 \u0026lt;- DimPlot(pbmc_2,reduction=\u0026#39;umap\u0026#39;,group.by = \u0026#34;type\u0026#34;, label = T, repel = F, shuffle = T) p = p1+p2+p3 ggsave(p,filename = \u0026#34;contrast_umap.pdf\u0026#34;,width = 24,height = 8)#fig.6.C ###对pbmc_2的meta.data可视化### #观察不同的细胞类型在肿瘤病人和正常病人之间的丰度比较，fig.6.D plotdata = pbmc_2@meta.data p \u0026lt;- ggplot( plotdata, aes(x=cell_type,fill = type) )+ geom_bar(position = \u0026#39;dodge\u0026#39;)+ scale_fill_igv(alpha = 0.7) ggsave(p,filename = \u0026#34;barplot.pdf\u0026#34;,width = 10,height = 6) #观察两类病人的不同细胞的构成比，fig.6.E p \u0026lt;- ggplot( plotdata, aes(x=type,fill = cell_type) )+ geom_bar(position = \u0026#39;fill\u0026#39;)+ scale_fill_igv(alpha = 0.7) ggsave(p,filename = \u0026#34;comparasion_barplot.pdf\u0026#34;,width = 4,height = 8) #对两个样本分别绘制umap，fig.6.F p \u0026lt;- UMAPPlot(pbmc_2, label = T, repel = F, split.by = \u0026#39;type\u0026#39;, group.by = \u0026#39;cell_type\u0026#39; )+ ggtitle(\u0026#39;UMAP\u0026#39;)+ theme_bw()+ theme( plot.title = element_text(face = \u0026#39;bold\u0026#39;,hjust = 0.5), plot.background = element_rect(fill = \u0026#39;transparent\u0026#39;,color = NA) )+ scale_color_igv() ggsave(p,filename = \u0026#34;splited_umap.pdf\u0026#34;,width = 15,height = 8) 图片 注释后差异基因可视化 说明 与上述寻找差异基因的过程类似，不过这次已经注释好了细胞类型，可以再次绘制差异表达基因的火山图、热图等，或者提取某一种特定的细胞，研究其在不同组间的表达差异。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #之前寻找差异基因的时候用的是自动生成的unintegrated_cluster作为分类依据，现在用注释好的cell_type作为分类依据 Idents(pbmc_2) \u0026lt;- \u0026#34;cell_type\u0026#34; #将cell_type设置为主要的分类标签 #FindAllMarkers函数会分析每个Idents中的差异表达基因 cell.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, #保留上调与下调的基因 test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcox检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #FindMarkers函数通过指定分组依据（group.by），以及两个ident，来寻找这两个ident之间的差异基因 degs = FindMarkers( pbmc_2, logfc.threshold = 0.5, only.pos = F, ident.1 = \u0026#39;Tumor cells\u0026#39;, ident.2 = \u0026#39;Intestinal epithelial cells\u0026#39;,#默认使用ident1 vs ident2，而不是相反 group.by = \u0026#39;cell_type\u0026#39; ) %\u0026gt;% mutate(gene=rownames(.))#将基因名等于行名方便后续操作 #如果想要观察特定细胞类型的差异基因，可以先提取子集，然后做类似操作。比如这里选择分析T细胞 Tcell_subtype = subset(pbmc_2 , cell_type == \u0026#39;T cells\u0026#39;) Tcell_degs = FindMarkers( Tcell_subtype, logfc.threshold = 0.5, only.pos = F, ident.1 = \u0026#39;Tumor\u0026#39;, ident.2 = \u0026#39;Normal\u0026#39;, group.by = \u0026#39;type\u0026#39; ) %\u0026gt;% mutate(gene=rownames(.)) ###可视化### #火山图 #对degs可视化，fig.7.A change = as.factor(ifelse(degs$p_val_adj \u0026lt; 0.05 \u0026amp; abs(degs$avg_log2FC) \u0026gt; 1, ifelse(degs$avg_log2FC \u0026gt; 1 ,\u0026#39;Up\u0026#39;,\u0026#39;Down\u0026#39;),\u0026#39;No change\u0026#39;))#标记上调下调基因 filtered_degs = degs %\u0026gt;% filter(p_val_adj\u0026lt;1e-100)%\u0026gt;% filter(abs(avg_log2FC)\u0026gt;3) degs$label \u0026lt;- ifelse(degs$gene %in% filtered_degs$gene, degs$gene, NA)#标记相当显著的基因 pdf(\u0026#34;Tumor_vs_Unknown_vol.pdf\u0026#34;,width=5,height=5)#绘制Tumor cells和Unknown组之间的差异基因 ggplot(degs, aes(avg_log2FC, -log10(p_val_adj)))+ geom_hline(yintercept = -log10(0.05), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_vline(xintercept = c(-1,1), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_point(aes(color = change), size = 0.2, alpha = 0.5) + theme_bw(base_size = 12)+ geom_text_repel(aes(label = label), size = 3, box.padding = 0.2, max.overlaps = 10) + # 防止重叠 scale_color_manual(values = c(\u0026#34;Up\u0026#34; = \u0026#34;red\u0026#34;, \u0026#34;Down\u0026#34; = \u0026#34;blue\u0026#34;, \u0026#34;No change\u0026#34; = \u0026#34;gray\u0026#34;))+ theme(panel.grid = element_blank(), legend.position = \u0026#39;right\u0026#39;)+ scale_x_continuous(limits = c(-max(abs(degs$avg_log2FC)), max(abs(degs$avg_log2FC))))#沿y轴对称 dev.off() #对Tcells在肿瘤组和正常组之间的差异表达基因进行可视化，fig.7.B change = as.factor(ifelse(Tcell_degs$p_val_adj \u0026lt; 0.05 \u0026amp; abs(Tcell_degs$avg_log2FC) \u0026gt; 1, ifelse(Tcell_degs$avg_log2FC \u0026gt; 1 ,\u0026#39;Up\u0026#39;,\u0026#39;Down\u0026#39;),\u0026#39;No change\u0026#39;)) filtered_Tcell_degs = Tcell_degs %\u0026gt;% filter(p_val_adj\u0026lt; 0.05 )%\u0026gt;% filter(abs(avg_log2FC)\u0026gt;1) Tcell_degs$label \u0026lt;- ifelse(Tcell_degs$gene %in% filtered_Tcell_degs$gene, Tcell_degs$gene, NA) pdf(\u0026#34;T_vol.pdf\u0026#34;,width=5,height=5) ggplot(Tcell_degs, aes(avg_log2FC, -log10(p_val_adj)))+ geom_hline(yintercept = -log10(0.05), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_vline(xintercept = c(-1,1), linetype = \u0026#34;dashed\u0026#34;, color = \u0026#34;#999999\u0026#34;)+ geom_point(aes(color = change), size = 0.2, alpha = 0.5) + theme_bw(base_size = 12)+ geom_text_repel(aes(label = label), size = 3, box.padding = 0.2, max.overlaps = 10) + # 防止重叠 scale_color_manual(values = c(\u0026#34;Up\u0026#34; = \u0026#34;red\u0026#34;, \u0026#34;Down\u0026#34; = \u0026#34;blue\u0026#34;, \u0026#34;No change\u0026#34; = \u0026#34;gray\u0026#34;))+ theme(panel.grid = element_blank(), legend.position = \u0026#39;right\u0026#39;)+ scale_x_continuous(limits = c(-max(abs(Tcell_degs$avg_log2FC)), max(abs(Tcell_degs$avg_log2FC)))) dev.off() #小提琴图，对每个类别的top3表达基因进行可视化，fig.7.C celldiff_top3 \u0026lt;- cell.markers %\u0026gt;% filter(avg_log2FC \u0026gt; 0) %\u0026gt;% group_by(cluster) %\u0026gt;% filter(avg_log2FC \u0026gt;3) %\u0026gt;% top_n(3,-p_val_adj) %\u0026gt;% group_by() VlnPlot(pbmc_2,features = celldiff_top3$gene, group.by = \u0026#34;cell_type\u0026#34;, split.plot = T, split.by = \u0026#39;type\u0026#39;, cols = c(\u0026#39;olivedrab\u0026#39;,\u0026#39;salmon\u0026#39;), stack = T, flip = T) ggsave(file = \u0026#39;vlnplot_celldiff_top3gene.pdf\u0026#39;,width = 8,height = 14) 图片 GO、KEGG、GSEA富集分析 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 library(tidyverse) library(clusterProfiler) library(enrichplot) Idents(pbmc_2) \u0026lt;- \u0026#34;cell_type\u0026#34; #将cell_type设置为主要的分类标签 cell.markers \u0026lt;- FindAllMarkers( object = pbmc_2, only.pos = F, test.use = \u0026#39;wilcox\u0026#39;, #检验方法是wilcox检验 slot = \u0026#39;data\u0026#39;, #默认使用data而不是counts min.pct = 0.25, #在至少25%的细胞内表达 logfc.threshold = 0.25 #设置log2FC的阈值 ) #以cell_type为分类依据，寻找每个类别的差异表达基因 Tumor_degs = cell.markers %\u0026gt;% filter(cluster == \u0026#34;Tumor cells\u0026#34;) %\u0026gt;% filter(p_val_adj \u0026lt; 0.05) %\u0026gt;% filter(abs(avg_log2FC) \u0026gt; 1) %\u0026gt;% arrange(desc(avg_log2FC)) #过滤差异表达基因 GO_database \u0026lt;- \u0026#39;org.Hs.eg.db\u0026#39; #将SYMBOL转ENTREZID ENTgene \u0026lt;- bitr(Tumor_degs$gene, fromType = \u0026#39;SYMBOL\u0026#39;, toType = \u0026#39;ENTREZID\u0026#39;, OrgDb = GO_database,drop = F) %\u0026gt;% distinct(SYMBOL,.keep_all = T) %\u0026gt;% drop_na() ENTgene \u0026lt;- dplyr::distinct(ENTgene,SYMBOL,.keep_all = T) ###GO富集分析,使用enrichGO函数### GO \u0026lt;- enrichGO( ENTgene$ENTREZID, OrgDb = GO_database, #即\u0026#39;org.Hs.eg.db\u0026#39;，即人类数据库 keyType = \u0026#34;ENTREZID\u0026#34;, ont = \u0026#34;all\u0026#34;, # 获取BP, CC, MF所有本体论的富集结果 pvalueCutoff = 0.01, qvalueCutoff = 0.01, readable = T ) #可视化barplot，fig.8.A pdf(\u0026#34;GO_Enrichment_all_ontology.pdf\u0026#34;,width=8,height=12) barplot( GO, split=\u0026#34;ONTOLOGY\u0026#34;, #按基因本体论分组 )+ facet_wrap(~ONTOLOGY, scales=\u0026#34;free\u0026#34;, ncol=1) dev.off() #可视化dotplot，fig.8.B pdf(\u0026#34;GO_Enrichment_all_ontology_dot.pdf\u0026#34;,width=10,height=20) dotplot(GO,split = \u0026#34;ONTOLOGY\u0026#34;) dev.off() ###KEGG分析### KEGG_database = \u0026#39;hsa\u0026#39; kegg_data \u0026lt;- enrichKEGG( gene = ENTgene$ENTREZID, keyType = \u0026#39;kegg\u0026#39;, organism = KEGG_database, pvalueCutoff = 0.05, qvalueCutoff = 0.05, use_internal_data = F ) %\u0026gt;% setReadable(.,OrgDb = GO_database,keyType = \u0026#39;ENTREZID\u0026#39;) kegg_data = setReadable(kegg_data, #前面分析的结果 OrgDb = \u0026#34;org.Hs.eg.db\u0026#34;, #人类数据库 keyType = \u0026#34;ENTREZID\u0026#34;) #要转换的基因类型 write.table(kegg_data,file=\u0026#34;kegg_data.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;,quote=F,row.names = F) #可视化barplot，fig.8.C pdf(file=\u0026#34;kegg_barplot.pdf\u0026#34;,width = 7,height = 5) barplot(kegg_data, x = \u0026#34;GeneRatio\u0026#34;, color = \u0026#34;p.adjust\u0026#34;, #默认参数 showCategory =10) #只显示前10 dev.off() #可视化dotplot，fig.8.D pdf(file=\u0026#34;kegg_dotplot.pdf\u0026#34;,width = 7,height = 5) dotplot(kegg_data,x = \u0026#34;GeneRatio\u0026#34;, color = \u0026#34;p.adjust\u0026#34;, size = \u0026#34;Count\u0026#34;, #默认参数 showCategory = 10) dev.off() #可视化colored cnetplot，fig.8.E Tumor_degs$SYMBOL = Tumor_degs$gene cnet_data = merge(Tumor_degs,ENTgene,by = \u0026#34;SYMBOL\u0026#34;) cnet_data = data.frame(cnet_data$ENTREZID,cnet_data$gene,cnet_data$avg_log2FC) logFC \u0026lt;- cnet_data$cnet_data.avg_log2FC names(logFC) \u0026lt;- cnet_data$cnet_data.gene pdf(file=\u0026#34;colored_kegg_cnetplot.pdf\u0026#34;,width = 10,height = 10) cnetplot(kegg_data, showCategory = 8, #选择top8的pathway ，这里也可以用包含pathway名称的向量 foldChange = logFC, colorEdge = T, node_label = \u0026#39;all\u0026#39;, max.overlaps = 50 ) dev.off() ###GSEA分析### expr_matrix = data.frame(Tumor_degs$SYMBOL,Tumor_degs$avg_log2FC) colnames(expr_matrix) \u0026lt;- c(\u0026#34;SYMBOL\u0026#34;,\u0026#34;Log2FoldChange\u0026#34;) merged_matrix = merge(expr_matrix,ENTgene,by = \u0026#34;SYMBOL\u0026#34;) data_sort \u0026lt;- arrange(merged_matrix,desc(Log2FoldChange)) #log2FC进行排序，这是GSEA分析必要的 gene_list \u0026lt;- data_sort$Log2FoldChange names(gene_list) \u0026lt;- data_sort$ENTREZID KEGG_database = \u0026#39;hsa\u0026#39; gsea \u0026lt;- gseKEGG(gene_list,organism = KEGG_database, pvalueCutoff = 0.05) gsea = setReadable(gsea, OrgDb = GO_database, keyType = \u0026#34;ENTREZID\u0026#34;) #可视化 pdf(file=\u0026#34;gsea_dotplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.F dotplot(gsea) dev.off() pdf(file=\u0026#34;gsea_ridgeplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.G ridgeplot(gsea,label_format = 100) dev.off() pdf(file=\u0026#34;gsea_gseaplot.pdf\u0026#34;, width = 12, height = 10) #fig.8.H gseaplot2(gsea,c(1:10),pvalue_table = F) dev.off() ###pathview图### library(pathview) library(tidyverse) pathview_data = Tumor_degs %\u0026gt;% filter(Tumor_degs$gene %in% as.factor(ENTgene$SYMBOL)) pathview_data$SYMBOL = pathview_data$gene pathview_data = merge(pathview_data,ENTgene,by = \u0026#39;SYMBOL\u0026#39;) pathview_data_draw = data.frame(pathview_data$ENTREZID,pathview_data$avg_log2FC) rownames(pathview_data_draw) = pathview_data_draw$pathview_data.ENTREZID colnames(pathview_data_draw) \u0026lt;- c(\u0026#39;ENTREZID\u0026#39;,\u0026#39;log2FC\u0026#39;) pathview_data_draw$ENTREZID \u0026lt;- as.numeric(pathview_data_draw$ENTREZID)#将ENTREZID列转化为数字 #绘图所需的数据是一个dataframe，行名是ENTREZID，两列分别是ENTREZID和log2FC #fig.8.I pathview(gene.data = pathview_data_draw, #上面包含行名为entrezID的logFC值的数据框 pathway.id = \u0026#34;hsa04390\u0026#34;, #选择一个KEGG信号通路,这里选的是hsa04650。更多通路见KEGG官网 species = \u0026#34;hsa\u0026#34;, out.suffix = \u0026#34;Tumor1\u0026#34;, #输出文件名 kegg.native = T ) #fig.8.J pathview(gene.data = pathview_data_draw, #上面包含行名为entrezID的logFC值的数据框 pathway.id = \u0026#34;hsa04390\u0026#34;, species = \u0026#34;hsa\u0026#34;, out.suffix = \u0026#34;Tumor2\u0026#34;, #输出文件名 kegg.native = F #以pdf保存，但是格式可能不好看 ) 图片 Cell Chat分析 说明 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 if (!require(CellChat)){ devtools::install_github(\u0026#34;jinworks/CellChat\u0026#34;) devtools::install_github(\u0026#39;immunogenomics/presto\u0026#39;) } library(CellChat) library(patchwork) data.input \u0026lt;- pbmc_2[[\u0026#34;RNA\u0026#34;]]$data #提取表达矩阵 labels \u0026lt;- Idents(pbmc_2) #提取主要分类标签，这里是cell_type meta \u0026lt;- data.frame(labels = labels, row.names = names(labels)) cellchat \u0026lt;- createCellChat(object = pbmc_2, group.by = \u0026#34;ident\u0026#34;, assay = \u0026#34;RNA\u0026#34;) #构建cellchat对象 CellChatDB \u0026lt;- CellChatDB.human #选择人类数据库 #展示该数据库中的数据类别的构成比，fig.9.A showDatabaseCategory(CellChatDB) ggsave(filename=\u0026#39;DBcategory.pdf\u0026#39;,width = 6, height = 4) #提取数据库的子集，选择“Sevreted Signaling”部分 CellChatDB.use \u0026lt;- subsetDB(CellChatDB, search = \u0026#34;Secreted Signaling\u0026#34;, key = \u0026#34;annotation\u0026#34;) cellchat@DB \u0026lt;- CellChatDB.use #将数据库更新到cellchat对象中 cellchat \u0026lt;- subsetData(cellchat) #从输入数据中提取与信号通路相关的配体和受体基因，不能省略 cellchat \u0026lt;- identifyOverExpressedGenes(cellchat) #识别在各群体中过表达的基因 cellchat \u0026lt;- identifyOverExpressedInteractions(cellchat) #根据过表达基因推断潜在的细胞相互作用 #使用人类蛋白质相互作用（PPI）网络平滑信号数据，改进噪声模型 cellchat \u0026lt;- smoothData(cellchat, adj = PPI.human) #cellchat包作者把projectData函数改为了smoothData函数! cellchat \u0026lt;- computeCommunProb(cellchat, type = \u0026#34;triMean\u0026#34;) #计算细胞间的通信概率，使用三均值法作为估算方式 cellchat \u0026lt;- filterCommunication(cellchat, min.cells = 10) #筛选通信事件，保留至少在 10 个细胞中检测到的通信对 cellchat \u0026lt;- computeCommunProbPathway(cellchat) #计算细胞间通讯的路径概率 cellchat \u0026lt;- aggregateNet(cellchat)#将细胞间通讯的网络聚合到更高的层次 groupSize \u0026lt;- as.numeric(table(cellchat@idents))#计算每种细胞类型的细胞数 #绘制弦图，fig.9.B pdf(file=\u0026#34;Interactions_string.pdf\u0026#34;,width = 5,height = 5) netVisual_circle( cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = \u0026#34;Number of interactions\u0026#34; ) dev.off() #绘制弦图，线的粗细为weights/strength，fig.9.C pdf(file=\u0026#34;Interactions_string_W_S.pdf\u0026#34;,width = 5,height = 5) netVisual_circle( cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = \u0026#34;Interaction weights/strength\u0026#34; ) dev.off() #绘制每一个类型的细胞与所有的细胞之间的通讯情况，fig.9.D mat \u0026lt;- cellchat@net$weight pdf(file=\u0026#39;plot_all.pdf\u0026#39;,12,6) par(mfrow = c(2,4), xpd=TRUE) for (i in 1:nrow(mat)) { mat2 \u0026lt;- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat)) mat2[i, ] \u0026lt;- mat[i, ] netVisual_circle( mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i] ) } dev.off() #单独显示一条通路，这里选择MIF通路。绘制弦图，fig.9.E cellchat@netP$pathways#涉及到的所有的pathway pathways.show \u0026lt;- c(\u0026#34;MIF\u0026#34;) pdf(file = \u0026#39;MIF signaling pathway network2.pdf\u0026#39;,width = 5, height = 5) netVisual_aggregate( cellchat, signaling = pathways.show, ) dev.off() #绘制另一种弦图，fig.9.F pdf(file = \u0026#39;chord_plot.pdf\u0026#39;,width = 10,height = 10) netVisual_aggregate( cellchat, signaling = pathways.show, layout = \u0026#34;chord\u0026#34; ) dev.off() #绘制热图，fig.9.G pdf(file = \u0026#39;heatmap_plot.pdf\u0026#39;,width = 10,height = 10) netVisual_heatmap( cellchat, signaling = pathways.show, color.heatmap = \u0026#34;Reds\u0026#34; ) dev.off() #计算该通路（MIF）中一些亚型的贡献占比，fig.9.H pdf(file = \u0026#34;MIF_Sub.pdf\u0026#34;,width = 5,height = 5) netAnalysis_contribution(cellchat, signaling = pathways.show) dev.off() #提取MIF通路中所有亚型 pairLR.CXCR4 \u0026lt;- extractEnrichedLR( cellchat, signaling = pathways.show, geneLR.return = FALSE ) #提取MIF-（CD74+CRCX4）通路，画出某一条通路的弦图，fig.9.I LR.show \u0026lt;- pairLR.CXCR4[1,] # show one ligand-receptor pair pdf(file = \u0026#39;MIF-CD74+CRCX4_signaling_pathway.pdf\u0026#39;,width = 5,height = 5) netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show) dev.off() #可视化所有通路的亚型占比，fig.9.J pathways.show.all \u0026lt;- cellchat@netP$pathways vertex.receiver = seq(1,4) for (i in 1:length(pathways.show.all)) { # Visualize communication network associated with both signaling pathway and individual L-R pairs netVisual(cellchat, signaling = pathways.show.all[i], vertex.receiver = vertex.receiver, layout = \u0026#34;hierarchy\u0026#34;) # Compute and visualize the contribution of each ligand-receptor pair to the overall signaling pathway if (i==1){ gg \u0026lt;- netAnalysis_contribution(cellchat, signaling = pathways.show.all[i]) } gg \u0026lt;- gg+netAnalysis_contribution(cellchat, signaling = pathways.show.all[i]) #ggsave(filename=paste0(pathways.show.all[i], \u0026#34;_L-R_contribution.pdf\u0026#34;), plot=gg, width = 3, height = 2, units = \u0026#39;in\u0026#39;, dpi = 300) } ggsave(file = \u0026#39;contribution_of_each_pathway.pdf\u0026#39;,width = 14,height = 10) #绘制气泡图，本质与弦图类似，fig.9.K pdf(file = \u0026#39;bubble2.pdf\u0026#39;,width = 5,height = 5) netVisual_bubble( cellchat, sources.use = c(2), #指定信号来源的细胞群体 targets.use = c(1:8), #指定信号接收的细胞群体 signaling = c(\u0026#34;MIF\u0026#34;,\u0026#34;CypA\u0026#34;), #指定可视化哪些信号通路 remove.isolate = FALSE #不移除信号强度低的通信对 ) dev.off() #指定源细胞群和目标细胞群，以及指定信号通路，绘制弦图，fig.9.L pdf(file = \u0026#39;Tumor_to_all_chord.pdf\u0026#39;,width = 7,height = 5) netVisual_chord_gene( cellchat, sources.use = c(2), #指定信号来源的细胞群体，编号为 1 到 8。 targets.use = c(1:8), #指定信号接收的细胞群体，编号为 1 到 8。 signaling = c(\u0026#34;MIF\u0026#34;), legend.pos.x = 8 #调整图在画布上的位置 ) dev.off() #绘制与指定信号通路相关的基因的表达的小提琴图，fig.9.M pdf(file = \u0026#39;cell_chat_Vlnplot_MIF.pdf\u0026#39;,width = 7,height = 5) plotGeneExpression( cellchat, signaling = \u0026#34;MIF\u0026#34;, #指定一条信号通路 enriched.only = TRUE, #只显示显著上调的基因 type = \u0026#34;violin\u0026#34; #绘制小提琴图 ) dev.off() #计算信号网络中各细胞群体的中心性指标（如度数、介数和接近中心性等） cellchat \u0026lt;- netAnalysis_computeCentrality( cellchat, slot.name = \u0026#34;netP\u0026#34; #指定数据来源为概率加权信号网络netP ) #绘制图像，可视化在该通路下每个细胞的作用如何，分为Sender、Receiver、Mediator和Influencer，fig.9.N pdf(file = \u0026#39;SignalingRole_heatmap.pdf\u0026#39;,width = 7,height = 5) netAnalysis_signalingRole_network( cellchat, signaling = pathways.show, #指定绘图的信号通路，这里是MIF width = 8, height = 2.5, font.size = 10 ) dev.off() #生成热图，展示每个细胞群体在信号网络中作为发送者（Sender）和接收者（Receiver）的能力，fig.9.O ht1 \u0026lt;- netAnalysis_signalingRole_heatmap( cellchat, pattern = \u0026#34;outgoing\u0026#34; ) ht2 \u0026lt;- netAnalysis_signalingRole_heatmap( cellchat, pattern = \u0026#34;incoming\u0026#34; ) pdf(file = \u0026#39;O_R_heatmap.pdf\u0026#39;,width = 12,height = 7) ht1+ht2 dev.off() library(NMF) library(ggalluvial) ###outgoing### #有两个参数： #Cophenetic相关系数，用于衡量数据在聚类时的保真度（fidelity） #Silhouette系数衡量每个点在聚类中的紧密度和聚类之间的分离度 #fig.9.P K \u0026lt;- selectK(cellchat, pattern = \u0026#34;outgoing\u0026#34;) pdf(file = \u0026#39;K_out.pdf\u0026#39;,width = 12,height = 7) K dev.off() #绘制聚类热图，fig.9.Q pdf(file = \u0026#39;CommuPattern_out.pdf\u0026#39;,width = 12,height = 5) nPatterns = 3 cellchat \u0026lt;- identifyCommunicationPatterns(cellchat, pattern = \u0026#34;outgoing\u0026#34;, k = nPatterns) dev.off() #聚类-riverplot-out，fig.9.R pdf(file = \u0026#39;riverplot_out.pdf\u0026#39;,width = 12,height = 7) netAnalysis_river(cellchat, pattern = \u0026#34;outgoing\u0026#34;) dev.off() #聚类-dotplot-out，fig.9.S pdf(file = \u0026#39;dotplot_out.pdf\u0026#39;,width = 12,height = 7) netAnalysis_dot(cellchat, pattern = \u0026#34;outgoing\u0026#34;) dev.off() ###incoming### #fig.9.T K \u0026lt;- selectK(cellchat, pattern = \u0026#34;incoming\u0026#34;) pdf(file = \u0026#39;K_in.pdf\u0026#39;,width = 12,height = 7) K dev.off() #聚类热图，fig.9.U pdf(file = \u0026#39;CommuPattern_in.pdf\u0026#39;,width = 12,height = 5) nPatterns = 3 cellchat \u0026lt;- identifyCommunicationPatterns(cellchat, pattern = \u0026#34;incoming\u0026#34;, k = nPatterns) dev.off() #聚类-riverplot-in，fig.9.V pdf(file = \u0026#39;riverplot_in.pdf\u0026#39;,width = 12,height = 7) netAnalysis_river(cellchat, pattern = \u0026#34;incoming\u0026#34;) dev.off() #聚类-dotplot-in，fig.9.W pdf(file = \u0026#39;dotplot_in.pdf\u0026#39;,width = 12,height = 7) netAnalysis_dot(cellchat, pattern = \u0026#34;incoming\u0026#34;) dev.off() 图片 ","date":"2024-12-14T00:00:00Z","image":"https://Detarame-ding.github.io/p/%E5%9F%BA%E4%BA%8Eseurat%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B/seurat_banner_hu12300301024957807398.jpg","permalink":"https://Detarame-ding.github.io/p/%E5%9F%BA%E4%BA%8Eseurat%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B/","title":"基于Seurat的单细胞分析标准流程"}]